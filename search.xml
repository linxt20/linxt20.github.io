<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git基础指令学习笔记</title>
      <link href="/2025/03/23/git_note/"/>
      <url>/2025/03/23/git_note/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>这部分只是记录作者自己不大熟练的git指令操作，如果需要详细的git操作教程，请自行百度</p></div><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>几个基础的指令就不写了<br>一个基础知识：pull &#x3D; fetch + merge</p><p>clone add commit push pull 这几个指令使用vscode的git界面进行操作更加方便快速</p><h1 id="版本跳跃"><a href="#版本跳跃" class="headerlink" title="版本跳跃"></a>版本跳跃</h1><p>vscode的git似乎在版本回退上操作不大方便，可能是我不大会使用，这里直接记录版本跳跃的git指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reflog // 查看所有的版本索引号</span><br><span class="line">git reset --hard // 版本索引号，可以前进也可以回退</span><br><span class="line">// 如果想要修改版本之后进行强制提交覆盖github上的内容，可以使用</span><br><span class="line">git push -f origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h1 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h1><p>vscode的版本比较的直观，但是似乎没法将本地库中的历史版本与当前版本进行比较，这里记录一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff [文件名] 将工作区中的文件和暂存区进行比较</span><br><span class="line">git diff [本地库中的历史版本] [文件名] 将工作区中的文件与本地库历史记录比较</span><br><span class="line">不指定文件名将会将工作区的所有文件都进行比较</span><br></pre></td></tr></table></figure><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p>vscode的git管理界面能够查看创建以及切换分支</p><p>如果在git bash中则使用一下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch -v 查看所有的分支以及当前在哪个分支上</span><br><span class="line">git branch [分支名称] 创建新的分支</span><br><span class="line">git checkout [分支名称] 切换到目标分支</span><br><span class="line">git checkout -b [分支名称] 创建并切换到目标分支</span><br><span class="line">git merge [分支名称] 将目标分支合并到当前所在的分支上 如果出现冲突，需要修改之后，add后commit</span><br></pre></td></tr></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>这部分第一次学习，做一个记录，平时似乎很少用到</p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt; 给当前的分支附上标签名</span><br><span class="line">git tag -a &lt;name&gt; -m &quot;introduction&quot; 附上标签名的同时加上描述，描述在git show展示</span><br><span class="line">git tag 查看所有的标签</span><br><span class="line">git tag &lt;name&gt; &lt;id&gt; 给id分支附上标签名</span><br><span class="line">git show &lt;tagname&gt; 查看tagname标签的信息</span><br></pre></td></tr></table></figure><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;可以推送一个本地标签；</span><br><span class="line">git push origin --tags可以推送全部未推送过的本地标签；</span><br><span class="line">git tag -d &lt;tagname&gt;可以删除一个本地标签；</span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。</span><br></pre></td></tr></table></figure><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="邀请队友"><a href="#邀请队友" class="headerlink" title="邀请队友"></a>邀请队友</h2><p>github项目仓库的setting中cooperation，输入队友账号即可</p><h2 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h2><p>fork队员在pull request中点击new pull request,created pull request,view pull request<br>项目队长在pull request中点击目标request<br>(团队间直接在github赋予权限就可以直接clone和pull、push)</p><h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2><p>.gitignore<br>常见白名单：<br>图片文件缩略图文件 *.ini<br>python文件的编译文件 *.py[cod] *.so *.egg *.egg-info dist build</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git check-ignore -v App.class 检查指定文件是由于哪行规则而进入白名单的</span><br></pre></td></tr></table></figure><p>不排除.gitignore和App.class的白名单写法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!.gitignore</span><br><span class="line">!App.class</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo butterfly中使用Font Awesome V5的icon图标</title>
      <link href="/2025/03/23/how_to_use_icon/"/>
      <url>/2025/03/23/how_to_use_icon/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本篇文章主要基于hexo的butterfly<a href="https://butterfly.js.org/posts/21cfbf15/">配置说明教程</a>以及一篇介绍<code>fas，fab</code>等内容的<a href="https://www.webdevsplanet.com/post/font-awesome-icon-style-classes">文章</a>，记录作者自身的学习笔记以及心得</p></div><h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>我在学习hexo butterfly主题配置教程时候，发现了如下一个奇怪的问题，位于<code>Butterfly 安裝文檔(三) 主題配置-1</code>中<br><img src="https://github.com/linxt20/blog_img/blob/master/how_to_use_icon/iconconfig.jpg?raw=true" title="icon部分配图错误" alt="icon部分配图错误"></p><p>根据教程的指引，<code>fas fa-envelope: mailto:xxxxxx@gmail.com || Email</code>中的<code>fas fa-envelope</code>是一个图标名，随后教程又贴心的放上来一张网页截图，告诉你图标名可以在这里寻找。细心的读者可能发现到了，这张网页截图中不正好有一个现成的图标名<code>fa-address-book</code>。于是我测试性的修改代码为<code>fa-address-book: mailto:xxxxxx@gmail.com || Email</code>,但是却发现图标没有显示。这时我发现到了教程中，这个网页截图中细心地为读者在关键内容处标注了红色框框，于是我又把代码修改为<code>fa fa-address-book: mailto:xxxxxx@gmail.com || Email</code>,刷新页面后依旧没有图标的踪影，这是什么情况？难道教程中提供的这个网页截图是错误的吗？</p><img src="https://github.com/linxt20/blog_img/blob/master/how_to_use_icon/font_awesome_v4%E7%BD%91%E9%A1%B5.jpg?raw=true" title="font_awesome_v4" alt="font_awesome_v4"><p>鉴于此，我经过一番搜索，最终还是找到了网页截图的出处网页<a href="https://www.thinkcmf.com/font/font_awesome/icon/address-book">(点击跳转)</a>,如上图。在这个网页提供的图标当中，我随便测试了几个,例如<code>fa fa-address-card</code>，<code>fa fa-etsy</code>等，在我的博客网页上都没法显示出对应的图标。</p><p>于是我又回到教程当中，对比了目前教程提供的<code>fab fa-github</code>,<code>fas fa-envelope</code>以及<code>fa fa-address-book</code>三个图标名，我发现到标签名的前缀<code>fa</code>,<code>fas</code>,<code>fab</code>各不相同，于是我依次尝试了<code>fas fa-address-book</code>和<code>fab fa-address-book</code>终于发现<code>fas fa-address-book</code>这个图标名能够成功显示出图标。</p><p>经历这一番搜索，我不禁有所疑问，对于像作者我这样的新手而言，怎么判断什么时候该使用<code>fas</code>什么时候该使用<code>fab</code>呢？是否还存在其他的前缀？这些前缀都表达什么含义？</p><p>于是我带着这些问题，再次进行一轮长时间的资料搜索。</p><h1 id="详解font-awesome的icon图标名前缀含义"><a href="#详解font-awesome的icon图标名前缀含义" class="headerlink" title="详解font_awesome的icon图标名前缀含义"></a>详解font_awesome的icon图标名前缀含义</h1><div class="note info modern"><p>这部分主要参考于<a href="https://www.webdevsplanet.com/post/font-awesome-icon-style-classes">font-awesome-icon-style-classes</a></p></div><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>font_awesome的icon图标名前缀总共有六种，分别为fa，fas，fab，fad，far和fal，下面来一一介绍。</p><h2 id="前缀fa"><a href="#前缀fa" class="headerlink" title="前缀fa"></a>前缀fa</h2><p>对于所有font awesome v5版本以前的图标，icon图标的前缀都是fa。例如教程中的网页截图的原网页<a href="https://www.thinkcmf.com/font/font_awesome/icon/address-book">(点击跳转)</a>，这个网页就是font awesome的v4版本网页，因此里面提供的icon都是拥有fa前缀的，但是由于hexo的butterfly主题目前配置的是最新的font awesome v5，而fa这个前缀在v5版本及其以后版本都将会被弃用，因此在butterfly主题中使用fa前缀的icon是没法显示的。</p><h2 id="前缀fas"><a href="#前缀fas" class="headerlink" title="前缀fas"></a>前缀fas</h2><p>fas中的s意味着solid(实心的，加粗的)的意思，图标的深灰色彩占据了图标设计的大部分。与其他样式相比，实心图标是最显眼、最醒目、最容易辨认的。</p><h2 id="前缀fab"><a href="#前缀fab" class="headerlink" title="前缀fab"></a>前缀fab</h2><p>fab中的b意味着brand(商标)的意思，因此fas前缀的icon图标都是一些品牌图标，例如github图标，csdn图标，google图标，facebook图标等。</p><h2 id="前缀fad"><a href="#前缀fad" class="headerlink" title="前缀fad"></a>前缀fad</h2><p>fad中的d意味着doutone(双色的)的意思，在fad为前缀的icon中，都是由两种颜色(基本上是深灰和浅灰)设计而来的。</p><h2 id="前缀far"><a href="#前缀far" class="headerlink" title="前缀far"></a>前缀far</h2><p>far中的r是regular(常规的)的意思，由于常规的icon图标都是使用矢量笔画设计的，这些图标表现出来的特点就是线条感比较简洁精细，图标呈现空心的效果，这与fas的solid恰恰是相反的。</p><h2 id="前缀fal"><a href="#前缀fal" class="headerlink" title="前缀fal"></a>前缀fal</h2><p>fal中的l是light(轻的)的意思，这个轻是相较于far的regular和fas的solid而言的，可以如下理解: fas是线条加粗，far是线条常规粗细，fal则是线条最为纤细。</p><h1 id="如何快速获取icon的编号以及其前缀"><a href="#如何快速获取icon的编号以及其前缀" class="headerlink" title="如何快速获取icon的编号以及其前缀"></a>如何快速获取icon的编号以及其前缀</h1><p>看了前面这么多前缀的介绍，读者可能感觉不是很好记忆。实际上，这一部分内容也是不用记忆的，纯粹理解一下就可以，这是因为font awesome V5-V6也有自己独立的网站<a href="https://fontawesome.com/">(点击跳转)</a>。在主页，点击导航栏的搜索图标，在随后的页面中输入自己想要的图标名，并点击对应的图标，网页将会显示一个页面如下,复制其中的<code>fa-solid fa-address-book</code>,黏贴到对应的位置即可。<br><img src="https://github.com/linxt20/blog_img/blob/master/how_to_use_icon/font_awesome_v5%E7%BD%91%E9%A1%B5.jpg?raw=true" title="font_awesome_v5" alt="font_awesome_v5"></p><p>细心的读者可能会疑惑为啥这里是<code>fa-solid</code>？实际上这是因为<code>fas</code>是第五版的写法，<code>fa-solid</code>则是第六版的写法，读者需要根据自己主题使用的是font awesome v5还是v6自行选择使用对应的前缀。以下将会整理第五版与第六版的前缀的对应关系。</p><table style="text-align:center;">    <tr>        <th>Version 5</th>        <th>Version 6</th>    </tr>    <tr>        <td>fas</td>        <td>fa-solid</td>    </tr>    <tr>        <td>fab</td>        <td>fa-brands</td>    </tr>    <tr>        <td>fad</td>        <td>fa-duotone</td>    </tr>    <tr>        <td>fal</td>        <td>fa-light</td>    </tr>    <tr>        <td>far</td>        <td>fa-regular</td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> icon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的butterfly主题配置笔记</title>
      <link href="/2025/03/23/hexo_butter_note/"/>
      <url>/2025/03/23/hexo_butter_note/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本篇文章主要基于hexo的butterfly<a href="https://butterfly.js.org/posts/21cfbf15/">配置说明教程</a>，记录作者自身的学习笔记以及心得</p></div><h1 id="front-matter-markdown文档配置记录"><a href="#front-matter-markdown文档配置记录" class="headerlink" title="front-matter markdown文档配置记录"></a>front-matter markdown文档配置记录</h1><h2 id="Page-Front-matter-用於頁面配置"><a href="#Page-Front-matter-用於頁面配置" class="headerlink" title="Page Front-matter 用於頁面配置"></a>Page Front-matter 用於頁面配置</h2><table>    <tr>        <th width="180px">content</th>        <th>introduction</th>    </tr>    <tr>        <td>title</td>        <td>【必需】頁面標題</td>    </tr>    <tr>        <td>date</td>        <td>【必需】頁面創建日期</td>    </tr>    <tr>        <td>type</td>        <td>【必需】標籤、分類和友情鏈接三個頁面需要配置</td>    </tr>    <tr>        <td>updated</td>        <td>【可選】頁面更新日期</td>    </tr>    <tr>        <td>description</td>        <td>【可選】頁面描述</td>    </tr>    <tr>        <td>keywords</td>        <td>【可選】頁面關鍵字</td>    </tr>    <tr>        <td>comments</td>        <td>【可選】顯示頁面評論模塊(默認 true)</td>    </tr>    <tr>        <td>top_img</td>        <td>【可選】頁面頂部圖片</td>    </tr>    <tr>        <td>mathjax</td>        <td>【可選】顯示mathjax(當設置mathjax的per_page: false時，才需要配置，默認 false)</td>    </tr>    <tr>        <td>katex</td>        <td>【可選】顯示katex(當設置katex的per_page: false時，才需要配置，默認 false)</td>    </tr>    <tr>        <td>aside</td>        <td>【可選】顯示側邊欄 (默認 true)</td>    </tr>    <tr>        <td>aplayer</td>        <td>【可選】在需要的頁面加載aplayer的js和css,請參考文章下面的音樂 配置</td>    </tr>    <tr>        <td>highlight_shrink</td>        <td>【可選】配置代碼框是否展開(true/false)(默認為設置中highlight_shrink的配置)</td>    </tr></table>        <h2 id="Post-Front-matter-用於文章頁配置"><a href="#Post-Front-matter-用於文章頁配置" class="headerlink" title="Post Front-matter 用於文章頁配置"></a>Post Front-matter 用於文章頁配置</h2><table>    <tr>        <th width="180px">content</th>        <th>introduction</th>    </tr>        <tr>        <td>sticky</td>        <td>【可選】把這篇文章置頂。數值越大，置頂的優先級越大</td>    </tr>    <tr>        <td>title</td>        <td>【必需】文章標題</td>    </tr>    <tr>        <td>date</td>        <td>【必需】文章創建日期</td>    </tr>    <tr>        <td>tags</td>        <td>【可選】文章標籤,使用[1,2,3]可以设置三个标签</td>    </tr>    <tr>        <td>categories</td>        <td>【可選】文章分類,如果要设置子分类或者多个分类，点击<a href="https://www.jianshu.com/p/bff1b1845ac9">参考文章</a></td>    </tr>    <tr>        <td>updated</td>        <td>【可選】文章更新日期</td>    </tr>    <tr>        <td>description</td>        <td>【可選】頁面描述</td>    </tr>    <tr>        <td>keywords</td>        <td>【可選】頁面關鍵字</td>    </tr>    <tr>        <td>comments</td>        <td>【可選】顯示頁面評論模塊(默認 true)</td>    </tr>    <tr>        <td>top_img</td>        <td>【可選】頁面頂部圖片</td>    </tr>    <tr>        <td>cover</td>        <td>【可選】文章縮略圖(如果沒有設置top_img,文章頁頂部將顯示縮略圖，可設為false/圖片地址/留空)</td>    </tr>    <tr>        <td>toc</td>        <td>【可選】顯示文章TOC(默認為設置中toc的enable配置)</td>    </tr>    <tr>        <td>toc_number</td>        <td>【可選】顯示toc_number(默認為設置中toc的number配置) </td>    </tr>    <tr>        <td>toc_style_simple</td>        <td>【可選】顯示 toc 簡潔模式</td>    </tr>    <tr>        <td>copyright</td>        <td>【可選】顯示文章版權模塊(默認為設置中post_copyright的enable配置),转载文章可以单独设置false</td>    </tr>    <tr>        <td>copyright_author</td>        <td>【可選】文章版權模塊的文章作者</td>    </tr>    <tr>        <td>copyright_author_href</td>        <td>【可選】文章版權模塊的文章作者鏈接</td>    </tr>    <tr>        <td>copyright_url</td>        <td>【可選】文章版權模塊的文章連結鏈接</td>    </tr>    <tr>        <td>copyright_info</td>        <td>【可選】文章版權模塊的版權聲明文字</td>    </tr>    <tr>        <td>mathjax</td>        <td>【可選】顯示mathjax(當設置mathjax的per_page: false時，才需要配置，默認 false)</td>    </tr>    <tr>        <td>katex</td>        <td>【可選】顯示katex(當設置katex的per_page: false時，才需要配置，默認 false)</td>    </tr>    <tr>        <td>aside</td>        <td>【可選】顯示側邊欄 (默認 true)</td>    </tr>    <tr>        <td>aplayer</td>        <td>【可選】在需要的頁面加載aplayer的js和css,請參考文章下面的音樂 配置</td>    </tr>    <tr>        <td>highlight_shrink</td>        <td>【可選】配置代碼框是否展開(true/false)(默認為設置中highlight_shrink的配置)</td>    </tr>    <tr>        <td>decode</td>        <td>【可選】版权链接显示，默認對網址進行解碼，以至於如果是中文網址，會被解碼，可設置true來顯示中文網址。</td>    </tr>    <tr>        <td>password</td>        <td>【可選】给文章设置查阅密码</td>    </tr></table><p>需要注意的是，如果发现以上front-matter设置不成功，请第一时间检查是否按照了对应的包，例如password需要安装hexo-blog-encrypt（不同front-matter对应什么包请自行百度查阅，注意查阅前提是设置不成功）</p><h1 id="主题markdown添加外挂标签写法记录"><a href="#主题markdown添加外挂标签写法记录" class="headerlink" title="主题markdown添加外挂标签写法记录"></a>主题markdown添加外挂标签写法记录</h1><h2 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h2><p>通用写法格式为；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>其中变量解释如下：</p><table>    <tr>        <th>名称</th>        <th>用法</th>    </tr>    <tr>        <td>color</td>        <td>【可選】顔色 (default / blue / pink / red / purple / orange / green)</td>    <tr>    <tr>        <td>icon</td>        <td>【可選】可配置自定義 icon (只支持 fontawesome 圖標, 也可以配置 no-icon )</td>    <tr>    <tr>        <td>style</td>        <td>【可選】可以覆蓋配置中的 style（simple/modern/flat/disabled）</td>    <tr></table><p>下面给两个例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--第一个例子是变量都不选择的情况，此时为默认情况，这个默认情况设置是在主题文件夹的<span class="emphasis">_config.yml文件当中--&gt;</span></span><br><span class="line"><span class="emphasis">&#123;% note %&#125;</span></span><br><span class="line"><span class="emphasis">你是刷 Visa 還是 UnionPay</span></span><br><span class="line"><span class="emphasis">&#123;% endnote %&#125;</span></span><br></pre></td></tr></table></figure><p>显示效果如下：</p><div class="note flat"><p>你是刷 Visa 還是 UnionPay</p></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--第二个例子是变量都选择的情况--&gt;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>展示效果如下：</p><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><p>看到这里，读者很可能向了解一下类似于’fas fa-bullhorn’的icon图表如何获取？<br/><br>可以点击后面文章链接了解详情<a href="/2025/03/23/how_to_use_icon/" title="hexo butterfly中使用Font Awesome V5的icon图标">hexo butterfly中使用Font Awesome V5的icon图标</a></p><h2 id="tabs分页标签"><a href="#tabs分页标签" class="headerlink" title="tabs分页标签"></a>tabs分页标签</h2><p>通用写法格式为；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>其中变量解释如下：</p><table>    <tr>        <th>名称</th>        <th>用法</th>    </tr>    <tr>        <td>unique name</td>        <td>【必写】需要注意，这个独一无二名字是指这个名字在这个页面上需要是独一无二的</td>    <tr>    <tr>        <td>index</td>        <td>【可選】指定初始显示第几个tab，不写默认为第一个，注意该变量从数字1开始，如果设置为-1，则表示不显示tab里面内容</td>    <tr>    <tr>        <td>tab caption</td>        <td>【可選】tab标签名，如果没有填写，则默认为unique name + 该标签的数字编号</td>    <tr>    <tr>        <td>icon</td>        <td>【可選】tab图标，如果没有填写，则默认为没有图标，如果有icon没有tab caption，此时的标签名为单独的图标，注意前面需要加一个@</td>    <tr></table>以下展示2个例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数值为3，表示指定显示3，数字为-1表示没有预先指定，没有数字表示默认显示第一个--&gt;</span></span><br><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>显示效果为：</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- tab 第一個Tab --&gt;</span></span><br><span class="line">**tab名字為第一個Tab**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- tab @fab fa-apple-pay --&gt;</span></span><br><span class="line">**只有圖標 沒有Tab名字**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- tab 炸彈@fas fa-bomb --&gt;</span></span><br><span class="line">**名字+icon**</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>显示效果为</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一個Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸彈</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字為第一個Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有圖標 沒有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="timeline写法"><a href="#timeline写法" class="headerlink" title="timeline写法"></a>timeline写法</h2><p>通用写法格式为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline title,color %&#125;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line">xxxxx</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line">xxxxx</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><p>变量解释如下：</p><table>    <tr>        <th>名称</th>        <th>用法</th>    </tr>    <tr>        <td>title</td>        <td>標題/時間線</td>    <tr>    <tr>        <td>color</td>        <td>[可选] timeline 顏色 blue / pink / red / purple / orange / green，没写则显示默认颜色</td>    <tr></table>简单举例一个<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 2022,blue %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line">這是測試頁面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>這是測試頁面</p></div></div></div><h2 id="文章内引用自己博客文章标签"><a href="#文章内引用自己博客文章标签" class="headerlink" title="文章内引用自己博客文章标签"></a>文章内引用自己博客文章标签</h2><p>使用格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link &quot;文章在post文件夹下的地址(注意不需要加后缀)&quot;%&#125;</span></span><br></pre></td></tr></table></figure><p>简单举例一个</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link &quot;how_</span>to<span class="emphasis">_use_</span>icon&quot;%&#125;</span><br></pre></td></tr></table></figure><p>显示效果为<a href="/2025/03/23/how_to_use_icon/" title="hexo butterfly中使用Font Awesome V5的icon图标">hexo butterfly中使用Font Awesome V5的icon图标</a></p><h2 id="文章内使用画廊标签展示图片"><a href="#文章内使用画廊标签展示图片" class="headerlink" title="文章内使用画廊标签展示图片"></a>文章内使用画廊标签展示图片</h2><p>图库页面使用格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&lt;!-- &#123;% galleryGroup name description link img-url %&#125; --&gt;</span><br><span class="line">&#123;% galleryGroup &#x27;星空&#x27; &#x27;手握明月摘星辰&#x27; &#x27;/pinacotheca/star&#x27; &#x27;/pinacotheca/img/starcover.jpg&#x27; %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>显示效果请点击导航栏的图库页面</p><p>画廊页面使用格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/star_flower.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;flower&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;flower&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>这个部分暂时没有显示效果，因为不大好看其实，我自己也没有用</p><h1 id="心得与要点记录"><a href="#心得与要点记录" class="headerlink" title="心得与要点记录"></a>心得与要点记录</h1><h2 id="安装配置gitalk的要点"><a href="#安装配置gitalk的要点" class="headerlink" title="安装配置gitalk的要点"></a>安装配置gitalk的要点</h2><img src="https://github.com/linxt20/blog_img/blob/master/note_of_butter_in_hexo/gitalkconfig.jpg?raw=true" title="gitalk配置" alt="gitalk配置">在配置gitalk的过程中，由于butterfly主题当前的版本比较的先进，因此需要操作的步骤相较于指导文档当中要少不少，总共仅仅需要两步- 1.注册GitHub Application并保留信息；- 2，在主题的`_config.yml`文件当中填写`gitalk`后面的信息即可，同时记得修改同文件下的`comment`随后的`use:` 为`use:Gitalk`<h2 id="安装配置local-search的要点"><a href="#安装配置local-search的要点" class="headerlink" title="安装配置local_search的要点"></a>安装配置local_search的要点</h2><img src="https://github.com/linxt20/blog_img/blob/master/note_of_butter_in_hexo/local_searchconfig.jpg?raw=true" title="local_search配置" alt="local_search配置">由于local_search的default设置非常完善，因此对于那部分需要配置在根目录_config.yml的内容其实可以省略（如果对这部分内容需要自定义设置的话可以自己再补充上，但是基础已经够用），因此只需要两步- 1.在项目根目录下输入`npm install hexo-generator-search --save`- 2.在主题配置文件_config.yml文件中，将local_search的enable设置为true即可<h2 id="教程文档部分错误"><a href="#教程文档部分错误" class="headerlink" title="教程文档部分错误"></a>教程文档部分错误</h2><p>在学习butterfly教程文档的时候发现了两个小问题，对于新手的话如果看到这两个错误可能会有点懵<br>以下图片位于<code>Butterfly 安裝文檔(二) 主題頁面</code>之内，<code>图库页面创建</code>以及<code>其子页面创建</code>部分内容</p><img src="https://github.com/linxt20/blog_img/blob/master/note_of_butter_in_hexo/graphconfig.jpg?raw=true" title="图库配置教程错误点" alt="图库配置教程错误点"><img src="https://github.com/linxt20/blog_img/blob/master/note_of_butter_in_hexo/subpageconfig.jpg?raw=true" title="子页面配置教程错误点" alt="子页面配置教程错误点"><p>可以看到教程当中标注这部分代码是<code>yaml</code>语言格式，很多人包括作者一开始都以为要这些内容添加在主题的<code>_config.yml</code>文件当中。但是作者经过一番摸索后，才发现这里其实应该写<code>markdown</code>，就是我们输入<code>hexo n page xxxx</code>后创建位于source文件夹中的的图库或者子页面markdown文件，我们需要把教程中的代码复制到我们创建的<code>xxxx</code>markdown文件中，才会有效果。</p><p>教程中还存在另一个问题，我在<a href="/2025/03/23/how_to_use_icon/" title="hexo butterfly中使用Font Awesome V5的icon图标">hexo butterfly中使用Font Awesome V5的icon图标</a>一文中做了一个较为详细的分析，欢迎指导。</p><h2 id="热知识"><a href="#热知识" class="headerlink" title="热知识"></a>热知识</h2><p>分类和图库支持文件夹嵌套以展示层级</p><h1 id="有待探索的部分"><a href="#有待探索的部分" class="headerlink" title="有待探索的部分"></a>有待探索的部分</h1><p>计划顺序如下：</p><ul><li>副标题内容整理</li><li>文字cover图片选择设置</li><li>top_img图片选择设置</li><li>页面音乐</li><li>整理文件树，局部自定义修改（如页面侧栏）</li><li>snackbar弹窗添加（应该是琐碎的工程，有时间再来）</li><li>更多的页面栏目？（考虑新页面写在分类里面，就不用新开一个栏目）</li><li>界面美化（404，加载中，主页，友情链接等等）</li><li>PWA？（暂时还不了解是什么东西）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>THU-2023年春嵌入式课程实验指南——大作业Part2-3</title>
      <link href="/2023/07/07/THU-embedded-guide-Part2-3/"/>
      <url>/2023/07/07/THU-embedded-guide-Part2-3/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>同样叠个甲，如果出现了本指南没有覆盖到的错误，还是需要求助有经验的同学。希望大家作业完成顺利。当然，如果有大佬觉得这篇指南的内容过于幼稚简单，受限于本人水平，还请多多见谅。</p></div><p>上一篇文章指路: <a href="./THU-embedded-guide-Part1.md">THU-2023年春嵌入式课程实验指南——大作业Part1</a></p><h2 id="题目要求概述"><a href="#题目要求概述" class="headerlink" title="题目要求概述"></a>题目要求概述</h2><p>经过Part1的学习，读者基本上对于嵌入式的开发流程以及WAV音频格式有了一个大致的了解，这一次的Part2和Part3的内容就是在Part1的基础上，完成一个音乐播放器的开发。</p><p>由于Part3的附加功能QT界面的开发，需要将Part2的代码迁移到QT当中，进行相应的适配和重构，所以这里就不再分开讲解，直接讲述QT项目下的代码结构和功能实现。</p><p>这里需要支持的功能如下：</p><ul><li>1、播放wav格式的音频</li><li>2、支持音量的调节</li><li>3、支持上下首歌曲切换</li><li>4、支持MP3格式音频的播放</li><li>5、支持0.5,1.0,1.5,2.0四种播放速度</li><li>6、支持快进快退10s</li><li>附加：实现能够在开发板上启动的GUI</li></ul><h2 id="部署环境简介"><a href="#部署环境简介" class="headerlink" title="部署环境简介"></a>部署环境简介</h2><ul><li>硬件环境<ul><li>电脑系统<ul><li>本实验中电脑系统为Windows 10、Windows 11和macOS均可顺利运行。</li></ul></li><li>开发板系统<ul><li>自9字班开始使用的新设备盒，注意开发板的启动模式选择EMMC启动</li></ul></li></ul></li><li>软件环境<ul><li>xshell版本: Xshell 7(Build 0122)</li><li>xftp版本: Xftp 7(Build 0119)</li><li>vmware版本: 16.2.2 build-19200509</li><li>ubuntu版本:  18.04.6 LTS (即课程提供的ubuntu)</li><li>QT版本: 5.14.1 (即课程提供的ubuntu当中内置的QT)</li></ul></li></ul><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><p>由于本次实验需要<code>使用QT完成附加功能GUI界面</code>，因此需要先对前两次实验完成的代码结构进行重构，将其模块化，方便后续功能的添加以及前端界面的调用。</p><p>代码重构之后，依次完成QT界面设计与槽函数的连接，文件导入，音频播放、暂停、继续、停止功能的逻辑，解码转换MP3格式音乐，重载QListWedgit组件实现歌曲切换逻辑，实现滑动条控制的音量调节，通过修改文件读取头实现快进快退，通过计时器播放进度条逻辑设计与播放结束逻辑，通过抽帧和插值技术完成倍速播放功能。总计代码量近1200行，不包含引用的minimp3.h头文件与QT的ui文件与资源文件。</p><h3 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h3><div class="note red modern"><p>可以结合<a href="https://github.com/linxt20/Embedded_Music_Player">参考代码</a>阅读实验流程，在实验操作流程当中遇到问题，可以先看下一节中的问题与解决，如果没有覆盖到读者的问题，那读者还需要去咨询有经验的同学。</p></div><ul><li>1、<strong>QT界面设计与槽函数的连接</strong>：这个部分需要考虑开发板的长宽比例(测量约为15.5cm:8.8cm)来<code>提前固定QT界面的大小</code>，这里使用的是800:460(这里是一个近似的比例，主要时方便元素排版设计)，能够避免设计元素在开发板上显示的拉伸变形。其他的前端工作主要是<code>控件的排版</code>以及相关图片、图标等的插入，一些次要工作的例如<code>按钮都添加悬浮动画</code>、<code>重新设计标题栏</code>等这里不赘述。除此之外，还需要还需要使用<code>QT的信号与槽机制</code>，将每个控件的信号与对应的槽函数进行连接，实现控件的操作。下图即为QT设计的页面ui：</li></ul><p><img src="https://github.com/linxt20/blog_img/blob/master/THU-embedded-guide-Part2-3/gui.jpg?raw=true" alt="gui展示"></p><p>其中播放栏中的按钮从左到右依次为<code>后退10s</code>,<code>播放暂停</code>,<code>快进10s</code>,<code>停止</code>,<code>导入歌曲</code>,<code>音量选择</code>,<code>倍速选择</code></p><p>其中播放列表右侧的按钮从上到下依次为 <code>上一曲(向上箭头)</code>,<code>下一曲(向下箭头)</code></p><ul><li><p>2、文件导入：使用QFileDialog打开文件对话框，将选取的文件信息插入到QListWidget控件当中，这里通过重载QListWidget组件，在其构造函数当中读取、存储文件的路径、文件名等基础信息，同时将信息展示在前端播放列表当中。</p></li><li><p>3、音频播放、暂停、继续、停止功能的逻辑：</p><ul><li>这个部分的前端显示逻辑通过变量<code>playing</code>和<code>播放进度条的数值</code>两个部分联合判断播放情况：对于playing为true的，调用播放逻辑的pause，对于play为false情况，如果进度条数值为0表示是新音乐，调用播放逻辑的play，不为0表示是之前被暂停的，调用播放逻辑的continue。除此之外，通过对于QListWidget组件的重载，给每个item添加上播放的标记信息，用于在播放列表显示乐曲的播放状态。</li><li>对于这个部分的播放逻辑，在Part2的部分，助教会提供一个留空的代码文件，补充十个lasound函数调用(直接参看代码或者csdn搜索lasound播放音乐可以获得结果)，在补全代码后，需要将这部分的代码迁移到QT当中，同时分成<code>读取文件头open_music_file</code>、<code>初始化pcm设备init_pcm</code>以及<code>播放play</code>三个模块，这里通过使用<code>playing</code>和<code>isplaying</code>两个变量分别表示<code>是否播放了音乐(用于开始和停止)</code>和<code>是否正在播放音乐(用于暂停和继续)</code>，随后在pause、continue和stop三个函数当中进行修改这两个播放状态来完成音乐的暂停、继续和停止的功能。</li><li>需要注意的是QT的主线程是用来绘画UI界面，因此播放的时候需要开启一个新的线程进行操作</li></ul></li><li><p>4、<strong>实现歌曲切换逻辑</strong>：这个部分是建立在前面的播放和停止的逻辑以及QListWidget组件之上</p><ul><li>在前端的显示上，通过<code>设置QListWidget的currentRow参数</code>，加一减一以及边界判断，即可在播放列表显示上实现歌曲的切换，最后一首歌往后切会回到第一首歌的<code>循环切换</code>。除此之外，这里还实现了<code>双击QListWidget中单个Item项的方式来进行歌曲的选择</code>。</li><li>在播放的逻辑上，清除当前歌曲的播放状态，通过getcurrentRow获取现在需要播放的新歌曲，调用播放按钮的槽函数即可实现播放</li></ul></li><li><p>5、<strong>解码转换MP3格式音乐</strong>：</p><ul><li>这个部分使用了minimp3这个单文件的音频转码库，虽然这个库可以将MP3直接转化为PCM设备能够接受的字符流，但是考虑到WAV和MP3需要复用一样的播放代码，所以这里采取的方式是使用minimp3先<code>将MP3文件转化为临时的WAV文件</code>，再调用前面的播放函数进行播放</li><li>这个MP3转成WAV的实现逻辑主要是学习了<a href="https://www.cnblogs.com/cpuimage/p/8282397.html">博客园的相关文章</a>，将在<a href="https://github.com/lieff/minimp3">minimp3的github</a>中minimp3.h文件下载并放进QT项目当中，随后在项目当中实现对于获取到的MP3文件，使用mp3dec_decode_frame函数读取MP3的文件头信息，使用realloc函数读取其文件数据流信息，再将这些信息根据WAV文件头的格式依次写入到临时的.temp.wav文件当中</li></ul></li><li><p>6、实现音量调节与界面滑条之间的同步：</p><ul><li>这个部分的显示逻辑，只有在程序开始是读取Player的volume信息进行初始化显示，随后的音量调节部分都是通过对于QSlider的调节触发设置的槽函数，槽函数当中直接获取QSlider的value，随后调用播放逻辑当中的音量设置。这里通过<code>使用QSlider组件实现了音量调节的连续性</code>。</li><li>在音量调节的实现上，这里可以参考代码的实现，这里主要介绍几个主要函数的功能以及简单的流程：<ul><li>初始化混音器：<code>snd_mixer_open()</code>打开混音器，<code>snd_mixer_attach()</code>将混音器连接到音频设备，<code>snd_mixer_selem_register()</code>为混音器注册简单元素类，<code>snd_mixer_load()</code>加载混音器设置。attach所连接的音频设备名称获取方式可以通过在命令行输入<code>aplay -l</code>即可获取到音频设备名称为<code>hw:o</code>，混音器名称为<code>Playback</code></li><li>创建简单元素ID并查找混音器元素：<code>snd_mixer_selem_id_alloca()</code>分配内存，<code>snd_mixer_selem_id_set_index()</code>和<code>snd_mixer_selem_id_set_name()</code>设置ID的索引和名称。<code>snd_mixer_find_selem()</code>根据简单元素ID找到对应的混音器元素。</li><li>获取音量范围：<code>snd_mixer_selem_get_playback_volume_range()</code>获取当前音量范围，以便在设置音量时使用正确的值。</li><li>设置音量：根据按键内容修改音量变量，然后使用<code>snd_mixer_selem_set_playback_volume_all()</code>将调整音量应用到设备上。</li></ul></li></ul></li><li><p>7、<strong>通过修改文件读取头实现快进快退</strong>：</p><ul><li>这个部分的前端逻辑很简单，点击快进或者快退按钮，直接调用播放逻辑当中的快进与快退函数，随后设置将当前的时间进度设置跳转到对应的数值</li><li>在播放逻辑部分，这里使用了<code>10 * rate * num_channels * bits_per_sample / 8</code>的公式来计算10s内正常速度读取的数据量，随后使用<code>ftell</code>函数获取当前文件指针读取的位置，返回值是数据量，随后简单判断一下快进和快退的边界情况， 确定下来需要切换的数量量，使用<code>fseek</code>函数设置文件指针的新的读取位置。这个时候播放函数在再次从文件中读取buffer的时候就会从新的文件指针的位置进行读取，从而实现了快进与快退。</li></ul></li><li><p>8、通过计时器播放进度条逻辑设计与播放结束逻辑：这里的主要工作是获取音乐的总秒数，随后通过当前播放的秒数去计算时间进度条的进度，然后将两个总秒数转化为时间格式显示出来。</p><ul><li>总秒数的获取，是在打开音乐文件的时候，通过<code>fseek(fp, 0, SEEK_END);</code>将文件指针放在文件的末尾，随后使用<code>fsize = ftell(fp);</code>读取到文件总的大小，再使用公式<code>fsize/(rate * num_channels * bits_per_sample / 8);</code>用总的文件大小除去每秒钟处理的数据量，就可以得到总的时间。</li><li>对于当前的播放的秒数的获取，在每次音乐开始播放的时候将会初始化当前时间为0s，随后开启计时器，设置每1s触发一次时间函数，在时间函数当中，当前的秒数每次添加上播放的倍数speed*1，作为最新的秒数</li><li>播放结束逻辑是当当前播放的秒数大于总的秒数的时候，调用停止按钮的槽函数，终止播放。</li></ul></li><li><p>9、(<strong>这个部分推荐看实验优化的第一条</strong>)通过基础的抽帧和插值思路完成倍速播放功能：倍速播放这个部分单纯通过修改采样率会导致音调随着变化，而实现或者调用短时傅里叶等高级时间拉伸算法又过于复杂，因此这里使用效果相对粗糙的抽帧技术实现大于1的倍速，使用插值技术实现小于1的倍速。</p><ul><li>抽帧技术的实现，这个部分的大概思路就是将需要输入PCM设备的播放数据进行切分，然后删除其中的部分数据。考虑到实现的复杂度，这里采用的是相对简单的<code>没有平滑处理的等距抽帧</code>的方式，于是引入了两个调整参数——k是切分的数量，m是相邻删除区域的间隔。在调整k和m的过程当中，有如下发现：m不变的情况下，不断增大k的值，会出现音质先急速下降，又缓慢回复的过程，同时伴随着音调从一开始的基本正常到k接近rate之后变得越来越高；k不变的情况下，不断增大m的值，可以发现音调基本没有变化，但是音质在缓慢地提高。这个过程可以通过音频波的形态进行理解，由于k值的增大，一个周期内数据被删除的越多，处理一个周期的时间长度变小，相对于的频率、音调就会变高；对于m值的增大，被删除的块更加集中，音频波的断裂数量相对越来越少，由此产生的杂音就相对较少。</li><li>插值技术的实现，这个部分的大概思路就是需要将输入PCM设备的播放数据进行细分和扩充。考虑到实现的复杂度，这里采用的是相对简单的<code>没有平滑处理的克隆</code>的方式。同样的引入了两个调整参数——k是切分的数量，m是相邻扩充区域的间隔。和抽帧相似的规律，在m不变的情况下，不断增加k，音调从开始的不变，最后变为低音; 在k不变的情况下，不断增加m，音质的杂音也会相对减少。</li><li>考虑到上述量种情况相似的规律，于是K需要尽可能取得小，k_per_size * m则需要尽可能取得大。为了进一步扩大 k_per_size * m的值，这里还将周期的大小增加了1倍，以取得相对更优的倍速效果。</li></ul></li></ul><h3 id="实验中遇到的问题与解决方法"><a href="#实验中遇到的问题与解决方法" class="headerlink" title="实验中遇到的问题与解决方法"></a>实验中遇到的问题与解决方法</h3><ul><li><p>1、<strong>音乐播放时候遇到开发板外放的音量无法调整，但是个开发板连接耳机的音量和虚拟机上的音量可以调解</strong>：这个问题在于混音器的设置出现了问题，需要注意想要在开发板外放时候能够正常调节音量，需要配置<code>snd_mixer_attach(mixer, &quot;hw:0&quot;);</code>当中的<code>hw:0</code>和<code>snd_mixer_selem_id_set_name(sid, &quot;Playback&quot;);</code>当中的<code>Playback</code>，但是这个配置无法在虚拟机上进行播放，在虚拟机上进行音量调节需要修改配置为<code>snd_mixer_attach(mixer, &quot;default&quot;);</code>当中的<code>default</code>和<code>snd_mixer_selem_id_set_name(sid, &quot;Master&quot;);</code>当中的<code>Master</code>。</p></li><li><p>2、解码MP3格式音乐：这个地方和GUI库的选择部分遇到了类似的问题，因为使用ffmpeg这个较为成熟的音频转化库也会遇到交叉编译链当中不存在这个工具需要自己手动配置进去的问题。解决方法：这里通过在网上查阅单头文件转化MP3的开源仓库，谷歌推荐了minimp3这个仓库，通过简单的阅读和资料的查阅，这个minimp3不需要额外的库环境，可以通过交叉编译，所以最后选这了minimp3这个音频转化库</p></li><li><p>3、QT编译需要alsa库：在将播放的部分代码迁移到QT后，点击编译一直报错，显示无法使用ALSA库的函数文件。解决方法：这是因为编译指令需要带有-lasound，这个需要在QT的pro文件当中配置，指定链接alsa库的选项，例如pro文件最后添加上LIBS +&#x3D; -lasound即可解决问题。如果是在Part2的编译中，需要在编译指令后加入-lasound，例如<code>$CC Music_App.c -o Music_App -lasound</code>。</p></li><li><p>4、获取音乐播放的总时长：虽然正确使用了<code>音频数据大小/(rate * num_channels * bits_per_sample / 8)</code>这个公式，但是在辨别谁才是真正的音频数据的大小的时候，遇到了很多的问题，尝试了sub_chunk2_size、buffer_size等数据都显示不正确。解决方法：这个地方需要获取的音频数据其实是整个文件的数据大小，这个可以从播放音频的时候使用fread的读取函数可以观察到，于是查阅资料找到可以读取整个文件长度的实际大小的操作<code>fseek(fp, 0, SEEK_END);</code>获取文件头指向文件末尾，<code>fsize = ftell(fp);</code>获取以及读取的数据，这样返回的数据就是整个文件的数据。</p></li><li><p>5、倍速技术选择：在倍速上先是尝试了调解采样率的操作后发现音调变化过大，使用密集抽帧和密集插值的方式也没有太差差别，音质反而还差了。所以这个问题花费了很长的时间去调研，了解到想要实现变速不变调，还不损音质，谷歌推荐可以考虑使用卷积插值、短时傅里叶等时间拉伸算法，但是这些算法相关的论文虽然是开源的，但是实现这些算法的代码并没有开源，而已经实现了这些时间拉伸算法的成熟音频库，却因为不在交叉编译链当中而无法使用。而直接从论文复现代码难度过大。解决方法：这里最后还是采用了抽帧和插值思路的方式，但是相比最初的尝试，这里的实现给其中加入了调整参数，花费了一个下午的时间调参炼丹出来了一个相对较优的结果，能够做到音调不变，杂音相对较少。</p></li><li><p>6、ftp传输中断异常：虽然助教介绍开发板说有4G的存储，但是实际上剩余的物理内存大约只有50MB(槽点太多)，当放入的文件大小超过这个大小的时候，传输会中断，文件会被损坏，这里的解决方式主要是选用小的音频文件，也可以使用U盘挂载在开发板上，然后直接读取U盘上的音频文件，这样就不会出现内存不足的问题。</p></li></ul><h2 id="实验优化"><a href="#实验优化" class="headerlink" title="实验优化"></a>实验优化</h2><p>1、支持更多的音频播放格式和使用成熟的时间拉伸算法：在作者实现了这个简陋的抽帧和插值思路的倍速代码后，有超级大佬研究出了将ffmpeg库编译到交叉编译环境的操作(啥都不懂的助教当然也不懂这个)，这里可以直接使用ffmepg库的音频转码以及倍速播放api完成相关的功能，实现效果非常稳定。这里指路超级大佬的<a href="https://github.com/ChenQiqian/linux-audio-player/blob/main/doc/ffmpeg.md">配置交叉编译指导文章</a></p><p>2、音乐播放的时间进度：由于计时器每秒更新一次进度，所显示的时间进度可能与实际播放进度存在0.5-1秒的误差。因此，拖拽进度条切换进度可能会有较大误差。优化思路是增加计时器的更新频率，缩小更新时间间隔，以尽可能减小误差。然后启用进度条的编辑功能，类似于快进和快退的方式实现自由的进度修改。</p><p>3、导入文件预转码MP3文件：这是因为在播放MP3前需要先将其转码为WAV，相对比较耗时，大约需要等待1s左右的时间，这个部分可以考虑在导入文件的时候，开一个新的线程，给每个MP3先预转码一个WAV文件，实现用空间换时间。</p><p>4、UI上的CD机图片可以新增旋转动画设计：这个部分在代码上的实现采用的是QPixmap格式的图片进行设置，QPixmap格式的图片可以设置一个transformed的旋转操作，只要给播放进度条设置一个监督触发函数，播放的时候触发设置QPixmap进行旋转就可以实现播放时候的一边旋转的CD机动画</p><h2 id="实验执行流程"><a href="#实验执行流程" class="headerlink" title="实验执行流程"></a>实验执行流程</h2><p>QT项目在开发板上的启动流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 先将QT项目文件夹拷贝一个副本(部分同学执行了下面的编译操作后项目变成了只读，所以最好拷贝用副本操作)，副本文件夹下，打开终端输入以下指令加载交叉编译环境</span></span><br><span class="line"><span class="built_in">source</span> /opt/st/myir/3.1-snapshot/environment-setup-cortexa7t2hf-neon-vfpv4-ostl-linux-gnueabi</span><br><span class="line"><span class="comment">## 随后用qmake编译QT项目</span></span><br><span class="line">qmake xxx.pro</span><br><span class="line"><span class="comment">## 最后用make指令编译得到可执行文件</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将可执行文件通过ftp传递到开发板上，在启动开发板后，在xshell当中运行以下指令关闭开发板的默认桌面进程，这样自己的QT程序启动了才能显示出来</span></span><br><span class="line">killall mxapp2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 随后依次输入以下指令赋予自己QT程序权限，并执行</span></span><br><span class="line"><span class="built_in">chmod</span> +x 可执行文件名</span><br><span class="line">./可执行文件名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 作业指南 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式基础语法笔记</title>
      <link href="/2023/07/01/regex-note/"/>
      <url>/2023/07/01/regex-note/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>这是在<a href="https://regexlearn.com/zh-cn/learn">regexlearn</a>上学习后所做的记录，这里暂时只记录基础的语法，方便以后查阅。高级的语法也是基础语法的组合，这里也不会过多的赘述，后面如果有看到比较巧妙地高级组合，也会继续扩充。</p></div><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>正则表达式的使用场景还是非常广泛的，对于我个人来说在vscode中的单文件搜索与整个项目搜索可能是我正则表达式使用最为频繁的场合。简单的单词字母匹配很多时候无法满足需求，而vscode的搜索也支持通过正则表达式进行匹配，之前没有系统学习过，也没必要，看过一遍有一个印象即可。</p><h1 id="正则匹配语法"><a href="#正则匹配语法" class="headerlink" title="正则匹配语法"></a>正则匹配语法</h1><h2 id="基础匹配"><a href="#基础匹配" class="headerlink" title="基础匹配"></a>基础匹配</h2><p>将想要查找的目标单词直接输入即可，例如想要查找<code>hello</code>，则直接输入<code>hello</code>即可。</p><h2 id="正则符号语义"><a href="#正则符号语义" class="headerlink" title="正则符号语义"></a>正则符号语义</h2><h3 id="内容符号"><a href="#内容符号" class="headerlink" title="内容符号"></a>内容符号</h3><p>匹配长度都为1</p><table><thead><tr><th>符号样式</th><th>符号含义</th><th>符号使用示例</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符,匹配长度为1</td><td><code>h.llo</code>可以匹配<code>hello</code></td></tr><tr><td>[abc]</td><td>字符集，匹配方括号中的任意字符，匹配长度为1</td><td><code>h[ae]llo</code>可以匹配<code>hello</code>或者<code>hallo</code></td></tr><tr><td>[^abc]</td><td>否定字符集，匹配除了方括号中的任意字符，匹配长度为1</td><td><code>h[^ae]llo</code>可以匹配<code>hillo</code>或者<code>hbllo</code></td></tr><tr><td>[a-z]</td><td>字符范围，匹配指定范围内的任意字符，匹配长度为1</td><td><code>h[a-z]llo</code>可以匹配<code>hallo</code>或者<code>hbllo</code></td></tr><tr><td>[0-9]</td><td>匹配方括号中的任意数字</td><td><code>h[0-9]llo</code>可以匹配<code>h1llo</code>或者<code>h2llo</code></td></tr><tr><td>[^0-9]</td><td>匹配除了方括号中的任意一个数字</td><td><code>h[^0-9]llo</code>可以匹配<code>hello</code>或者<code>hbllo</code></td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td><td><code>h\wllo</code>可以匹配<code>h1llo</code>或者<code>h_llo</code>或者<code>h汉llo</code></td></tr><tr><td>\W</td><td>匹配任意不是字母或数字或下划线或汉字的字符</td><td><code>h\Wllo</code>可以匹配<code>h*llo</code>或者<code>h#llo</code></td></tr><tr><td>\s</td><td>匹配任意空白字符，包括空格、制表符、换页符等</td><td><code>h\sllo</code>可以匹配<code>h llo</code>或者<code>hllo</code></td></tr><tr><td>\S</td><td>匹配任意非空白字符</td><td><code>h\Sllo</code>可以匹配<code>h*llo</code>或者<code>h#llo</code></td></tr><tr><td>\d</td><td>匹配任意数字</td><td><code>h\dllo</code>可以匹配<code>h1llo</code>或者<code>h2llo</code></td></tr><tr><td>\D</td><td>匹配任意非数字</td><td><code>h\Dllo</code>可以匹配<code>hello</code>或者<code>hbllo</code></td></tr><tr><td>[\u4e00-\u9fa5]</td><td>匹配中文字符</td><td><code>h[\u4e00-\u9fa5]llo</code>可以匹配<code>h汉llo</code></td></tr></tbody></table><h3 id="重复符号"><a href="#重复符号" class="headerlink" title="重复符号"></a>重复符号</h3><table><thead><tr><th>符号样式</th><th>符号含义</th><th>符号使用示例</th></tr></thead><tbody><tr><td>*</td><td>匹配前面的子表达式零次或多次</td><td><code>ab*c</code>可以匹配<code>ac</code>或者<code>abc</code>或者<code>abbc</code></td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次</td><td><code>ab+c</code>可以匹配<code>abc</code>或者<code>abbc</code></td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次</td><td><code>ab?c</code>可以匹配<code>ac</code>或者<code>abc</code></td></tr><tr><td>{n}</td><td>匹配前面的子表达式n次</td><td><code>ab&#123;2&#125;c</code>可以匹配<code>abbc</code></td></tr><tr><td>{n,}</td><td>匹配前面的子表达式至少n次</td><td><code>ab&#123;2,&#125;c</code>可以匹配<code>abbc</code>或者<code>abbbc</code></td></tr><tr><td>{n,m}</td><td>匹配前面的子表达式至少n次，至多m次</td><td><code>ab&#123;2,3&#125;c</code>可以匹配<code>abbc</code>或者<code>abbbc</code></td></tr></tbody></table><h3 id="位置符号"><a href="#位置符号" class="headerlink" title="位置符号"></a>位置符号</h3><table><thead><tr><th>符号样式</th><th>符号含义</th><th>符号使用示例</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串的开始位置</td><td><code>^hello</code>可以匹配<code>hello world</code>中的<code>hello</code></td></tr><tr><td>$</td><td>匹配输入字符串的结束位置</td><td><code>hello$</code>可以匹配<code>hello world</code>中的<code>hello</code></td></tr><tr><td>\b</td><td>匹配一个单词边界，即字与空格间的位置</td><td><code>\bhello\b</code>可以匹配<code>hello world</code>中的<code>hello</code></td></tr><tr><td>\B</td><td>匹配非单词边界</td><td><code>\Bhello\B</code>可以匹配<code>hello world</code>中的<code>hello</code></td></tr></tbody></table><h3 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h3><table><thead><tr><th>符号样式</th><th>符号含义</th><th>符号使用示例</th></tr></thead><tbody><tr><td>()</td><td>分组，标记一个子表达式的开始和结束位置</td><td><code>(hello)&#123;2&#125;</code>可以匹配<code>hellohello</code></td></tr><tr><td>\1 \2</td><td>引用组，匹配第一个或第二个括号内匹配的内容</td><td><code>(ha)-\1,(haa)-\2</code>可以匹配<code>ha-ha,haa-haa</code></td></tr><tr><td>(?: )</td><td>非捕获分组，匹配但不捕获</td><td><code>(?:ha)-ha,(haa)-\1</code>可以匹配<code>ha-ha,haa-haa</code></td></tr><tr><td>|</td><td>或，匹配左右任意一个表达式</td><td><code>hello|world</code>可以匹配<code>hello</code>或者<code>world</code></td></tr><tr><td>\</td><td>转义符，将符号转义为普通字符</td><td><code>\*</code>可以匹配<code>*</code></td></tr></tbody></table><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><table><thead><tr><th>符号样式</th><th>符号含义</th><th>符号使用示例</th></tr></thead><tbody><tr><td>(?&#x3D;)</td><td>零宽度正预测先行断言，匹配一个位置，该位置后面能匹配表达式exp</td><td><code>hello(?=world)</code>可以匹配<code>helloworld</code>中的<code>hello</code></td></tr><tr><td>(?!)</td><td>零宽度负预测先行断言，匹配一个位置，该位置后面不能匹配表达式exp</td><td><code>hello(?!world)</code>可以匹配<code>hello</code>或者<code>hello world</code>中的<code>hello</code></td></tr><tr><td>(?&lt;&#x3D;)</td><td>零宽度正回顾后发断言，匹配一个位置，该位置前面能匹配表达式exp</td><td><code>(?&lt;=hello)world</code>可以匹配<code>helloworld</code>中的<code>world</code></td></tr><tr><td>(?&lt;!)</td><td>零宽度负回顾后发断言，匹配一个位置，该位置前面不能匹配表达式exp</td><td><code>(?&lt;!hello)world</code>可以匹配<code>world</code>或者<code>helloworld</code>中的<code>world</code></td></tr></tbody></table><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table><thead><tr><th>符号样式</th><th>符号含义</th><th>符号使用示例</th></tr></thead><tbody><tr><td>(?#)</td><td>注释，不影响正则表达式的匹配结果</td><td><code>hello(?#world)</code>可以匹配<code>helloworld</code>中的<code>hello</code></td></tr></tbody></table><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>正则表达式默认执行贪婪匹配，匹配的内容尽可能长</p><ul><li>贪婪匹配：对”ber beer beeer beeeer”使用 .*r 进行匹配，它匹配任何以 r 结尾的字符串，以及前面带有该字符串的文本，但它不会在第一个 r 处停止匹配。</li><li>懒惰匹配：对”ber beer beeer beeeer”使用 .*?r 进行匹配，它在 * 之后添加 ?，将查找以 r 结尾且前面带有任意字符的第一个匹配项。这意味着本次匹配将会在第一个字母 r 处停止。</li></ul><h1 id="高级正则表达式技巧"><a href="#高级正则表达式技巧" class="headerlink" title="高级正则表达式技巧"></a>高级正则表达式技巧</h1><div class="note info modern"><p>等待后续更新</p></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> regex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware的网络连接——桥接与NAT的选择与配置</title>
      <link href="/2023/05/15/vmware-network-connect/"/>
      <url>/2023/05/15/vmware-network-connect/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>这里作者使用的VMware版本为16.2.2 build-19200509，使用的ubuntu版本为18.04.6LTS，这里讨论的均为无线网络</p></div><h2 id="桥接与NAT的区别"><a href="#桥接与NAT的区别" class="headerlink" title="桥接与NAT的区别"></a>桥接与NAT的区别</h2><ul><li><p>桥接模式：虚拟机的网卡将会桥接到宿主机的物理网卡，使得虚拟机拥有区别于宿主机的IP，能够作为一个独立于宿主机的设备在网络中与其他的设备进行通信。</p></li><li><p>NAT模式：虚拟机的网络流量通过宿主机的物理网卡转发，在这种模式下，宿主机相当于虚拟机与外界通信的一个中转站，虚拟机传输给外界的信息包需要在宿主机中修改为宿主机的ip分发出去。</p></li><li><p>区别：简而言之，在NAT模式下，虚拟机通过宿主机进行网络通信，而在桥接模式下，虚拟机直接与网络进行通信。基于这些区别，两者的优缺点如下：</p><ul><li>NAT模式可以提供一定的网络隔离，增加安全性，但可能会带来一定的网络性能损耗。</li><li>桥接模式可以提供更高的网络性能，但可能需要更复杂的网络配置。</li></ul></li></ul><h2 id="使用VMware的桥接模式联网"><a href="#使用VMware的桥接模式联网" class="headerlink" title="使用VMware的桥接模式联网"></a>使用VMware的桥接模式联网</h2><p>使用桥接模式联网的操作相对比较繁琐一点，这里主要参考了CSDN上的<a href="https://blog.csdn.net/weixin_42627397/article/details/110826285">VMware虚拟机配置Ubuntu桥接方式</a>,虽然这篇博客相比于其他的博客讲述更加的简洁，但是在ip配置上反而有些过于省略，而且Ubuntu的版本和我的有一些差距，在修改网络配置的时候有些许区别。</p><p>我这里写一个完整版本：</p><ul><li>1、首先关闭虚拟机，这里需要关机而不是挂起，否则无法修改后面的网络适配器</li><li>2、按照下图的指示依次点击<code>编辑虚拟器设置</code>，<code>网络适配器</code>，<code>桥接模式</code>(下面的赋值物理网络连接状态不需要勾选),点击完后不要忘记点击下方的<code>确认</code>保存设置<br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/bridgemodelconnect1.jpg?raw=true" alt="桥接模式连接流程1"></li><li>3、点击VMware左上角的<code>编辑</code>-&gt;<code>虚拟机网络编辑器</code>,随后按照下图的指示在上方选择<code>VMnet0 桥接模式</code>,随后在已桥接至的下拉框选择<code>自动</code>即可，最后记得依次点击下方的<code>应用</code>和<code>确认</code>保存设置(如果没有修改的话<code>应用</code>不用点，也没法点)<br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/bridgemodelconnect2.jpg?raw=true" alt="桥接模式连接流程2"></li><li>4、虚拟机开机，在虚拟机的右上角，按照下图3的指示，打开网络设置的编辑页面(注意不同的虚拟机版本打开网络设置页面的方式可能有所不同),随后按照下图4的指示，如果网络没有打开先打开网络到ON，然后点击设置<br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/bridgemodelconnect3.jpg?raw=true" alt="桥接模式连接流程3"><br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/bridgemodelconnect4.jpg?raw=true" alt="桥接模式连接流程4"></li><li>5、在宿主机中，打开cmd命令行窗口，输入指令<code>ipconfig /all</code>可以显示出所有的网络接口的详细信息，找到自己当前正在使用的无线网，如下图5，在虚拟机中，按照下图6的流程点击进入IPv4的配置页面，选择Manual(手动模式)，**这里需要注意的是 Address的ip地址需要和宿主机的ip地址有所不同，例如我的宿主机现在ip地址是<code>192.168.43.78</code>,那我给虚拟机设置的ip地址可以是<code>192.168.43.77</code>**，后面的子网、网关和DNS根据图5获取的信息填写即可。完成后点击右上角的apply(应用)保存设置。<br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/bridgemodelconnect5.jpg?raw=true" alt="桥接模式连接流程5"><br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/bridgemodelconnect6.jpg?raw=true" alt="桥接模式连接流程6"></li><li>6、现在虚拟机中已经可以正常访问网络，这里随后复制一个CSDN的网址，如下：<br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/NATconnectsuccess.jpg?raw=true" alt="成功连接网络"></li></ul><p>这个部分会出现的问题有下面几个：</p><ul><li><p>1、在校园网下，使用桥接模式，经过上面的配置后，虚拟机中依旧无法联网(可能不是所有的校园网都有这个问题，至少作者使用的校园网存在这个问题):</p><ul><li>可能原因: 无线路由器和接入点通常会限制哪些设备可以通过MAC地址连接。当虚拟机尝试以其自己的MAC地址通过桥接模式连接时，无线网络可能不会接受这个新的设备。</li></ul></li><li><p>2、配置完后虚拟机中可以联网，但是宿主机中无法联网，关闭虚拟机当中的网络连接，宿主机中可以联网</p><ul><li>原因：配置过程的第五步中，没有按照加粗字体的提示，错误地设置虚拟机的ip和宿主机一样，这样由于桥接模式相当于一个独立的设备，虚拟机抢占了宿主机的ip，导致宿主机无法联网</li><li>解决方式：按照配置过程的第五步的加粗字体要求，设置虚拟机的ip地址与宿主机的ip地址不同</li></ul></li><li><p>3、配置完后无法联网(先排除了校园网的情况)</p><ul><li>可能原因：可能刚刚完成的配置还没有被同步应用到虚拟机中</li><li>解决方式：这个问题部分博客说是需要重启虚拟机，这是不必要的，这里断开网络连接后重新启动网络连接就可以</li></ul></li><li><p>4、有的读者可能会好奇，为什么通过这种配置不需要输入无线网络的密码，虚拟机就可以访问</p><ul><li>原因：这是因为对于桥接模式而言，桥接模式将虚拟机地网卡桥接到了宿主机的网卡上，两者使用的网络连接是相同的，也就是在宿主机上已经输入过密码并且连接成功的无线网络，在虚拟机当中可以直接利用这个已经建立的连接进行网络访问。虚拟机并没有建立一个新的独立的连接。</li></ul></li></ul><h2 id="使用VMware的NAT模式联网"><a href="#使用VMware的NAT模式联网" class="headerlink" title="使用VMware的NAT模式联网"></a>使用VMware的NAT模式联网</h2><p>使用NAT模式联网的操作非常简洁，流程如下：</p><ul><li>1、首先关闭虚拟机，这里需要关机而不是挂起，否则无法修改后面的网络适配器</li><li>2、按照下面的指示依次点击<code>编辑虚拟器设置</code>，<code>网络适配器</code>，<code>NAT模式</code>,点击完后不要忘记点击下方的<code>确认</code>保存设置<br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/NATmodelconnect.jpg?raw=true" alt="NAT模式联网流程"></li><li>3、随后开机即显示联网，随手复制个CSDN的网址进去可以正常访问<br><img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/NATconnectsuccess.jpg?raw=true" alt="成功连接网络"></li></ul><p>这个部分可能会出现的问题有：</p><ul><li>1、读者尝试完前面的桥接模式，想要也尝试一下NAT模式，但是发现按照上面的配置完，无法连接网络<ul><li>原因：桥接模式中对于虚拟机中的网络配置没有清除，两者之间存在冲突</li><li>解决方式：在虚拟机的网络设置当中，按照下图的操作后，点击应用，关闭网络连接再重启即可 <img src="https://github.com/linxt20/blog_img/blob/master/vmware-network-connect/closebridgemodel.jpg?raw=true" alt="关闭桥接模式的设置"></li></ul></li></ul><h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><p>这里暂时还没有解决，等待后续补充解决</p><p>目前有两个解决方向：</p><ul><li><p>主机代理共享：</p><ul><li>目前主机代理共享遇到的问题是：主机机器的防火墙可能阻止虚拟机通过VPN或代理访问网络。可能需要在防火墙中允许Clash代理端口的入站和出站连接。</li></ul></li><li><p>VMware独立配置代理</p><ul><li>这个部分需要在VMware当中安装VPN软件，随后在桥接模式下使用，应该可以成功实现代理，后续进行测试后会将结果记录在这里。但是这个方式还需要在虚拟机单独配置VPN，可能没有主机代理共享方式的方便。</li></ul></li></ul><p>这里还有一个不推荐的方式：</p><ul><li>这个方式是CSDN社区文章——<a href="https://blog.csdn.net/weixin_45934869/article/details/129100574">VMware桥接模式虚拟机上网问题踩坑</a>中提出来了，这篇文章当中提出在宿主机的Clash中打开<code>Allow LAN</code>的方式让虚拟机共享主机的代理，其中Clash的”Allow LAN”是一中 允许局域网(LAN)内的其他设备连接到运行Clash的设备，并使用它作为代理服务器的方式。但是不论是宿主机是连接了手机热点还是校园网，在这个局域网内，其他连接了手机热点还是校园网的设备都可以走这个宿主机的代理，这样造成的一方面是流量的问题，另一方面还是宿主机的网络安全问题。所以很不推荐这种方式实现代理共享。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> vmware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在windows上使用pycharm调试superset的配置</title>
      <link href="/2023/05/09/superset-debug-windows-pycharm/"/>
      <url>/2023/05/09/superset-debug-windows-pycharm/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>这篇文章的主要参考对象为一篇linux&#x2F;mac系统的配置<a href="https://medium.com/@jayakrishnan.karolil_46246/how-to-run-and-debug-apache-superset-using-pycharm-cdc308fc87b2">文章</a>，这篇文章将其配置迁移拟合到windows上</p></div><h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><ul><li>superset源码一份，直接从superset的github上pull即可</li><li>通过虚拟环境启动superset，参考我的另一篇博客——<a href="./superset-install-run.md">superset的安装与启动——虚拟环境与docker</a></li><li>pycharm工具，作者使用的是专业版(学生认证)</li><li>windows 10</li></ul><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><ul><li>1、首先是打开pycharm，点击右上角的运行按钮左侧下拉框，选择<code>Edit Configurations</code><br><img src="https://github.com/linxt20/blog_img/blob/master/superset-debug-windows-pycharm/edit-config.jpg?raw=true" alt="进入编辑详情"></li><li>2、对于打开的配置界面，点击左上角的加号，在展开的列表里面找到python，点击<br><img src="https://github.com/linxt20/blog_img/blob/master/superset-debug-windows-pycharm/select-python.jpg?raw=true" alt="选择python配置"></li><li>3、<strong>对于打开的python配置页面，在第二行的script path的右侧有个小三角，点击后选择module name</strong>(这个是区别于linux&#x2F;mac操作系统的关键)<br><img src="https://github.com/linxt20/blog_img/blob/master/superset-debug-windows-pycharm/select-module.jpg?raw=true" alt="选择模块名"></li><li>4、将下面的参数填写到对应位置，依次点击<code>Apply</code>和<code>OK</code>即可<ul><li>Name:flask-server(这个名字是随意的)</li><li>Module name: flask</li><li>Parameters: run -p 8088 –with-threads –reload –debugger</li><li>Environment variables: PYTHONUNBUFFERED&#x3D;1;FLASK_APP&#x3D;superset;FLASK_ENV&#x3D;development</li><li>Python interpreter:这里选择你是用的python解释器即可<br><img src="https://github.com/linxt20/blog_img/blob/master/superset-debug-windows-pycharm/config-detail.jpg?raw=true" alt="配置详细图"></li></ul></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>作者在配置这个的时候，一开始看出了venv中linux和windows的不同，但是发现修改之后还是不正确，因为script path没法选中不是py后缀的flask.exe，我强行输入后运行也会报错；于是我查阅资料，看看有没有其他的方式，中间尝试过用flask_server(可以使用flask.exe)和terminal shell(可以处理flask启动superset的参数指令)来进行配置，但是都存在部分信息无法补充的情况。最后我无意中点击到了这个script path，发现它是可以选择module name的，参考前面在flask_server的时候就是选择module name的，于是选择了falsk,最后也是很顺利的打开了调试器。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 调试 </category>
          
          <category> superset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>THU-2023年春嵌入式课程实验指南——大作业Part1</title>
      <link href="/2023/04/21/THU-embedded-guide-Part1/"/>
      <url>/2023/04/21/THU-embedded-guide-Part1/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>先叠个甲，如果出现了本指南没有覆盖到的错误，还是需要求助有经验的同学。希望大家作业完成顺利。当然，如果有大佬觉得这篇指南的内容过于幼稚简单，受限于本人水平，还请多多见谅。</p></div><p>下一篇文章指路: <a href="./THU-embedded-guide-Part2-3.md">THU-2023年春嵌入式课程实验指南——大作业Part2-3</a></p><h2 id="题目要求概述"><a href="#题目要求概述" class="headerlink" title="题目要求概述"></a>题目要求概述</h2><ul><li>1、使用系统I&#x2F;O函数读取WAV音频文件，并将音频文件参数输出至命令行。</li><li>2、将上一步读取到的音频文件参数写入开发平台上的txt文件中。</li><li>3、实验最终结果为：在开发板中运行目标程序后，会在同目录文件夹下生成一个与音乐文件名同名的txt文件，文件中包含有WAV音频文件的参数。</li></ul><h2 id="部署环境简介"><a href="#部署环境简介" class="headerlink" title="部署环境简介"></a>部署环境简介</h2><ul><li>硬件环境<ul><li>电脑系统<ul><li>本实验中电脑系统为Windows 10、Windows 11和macOS均可顺利运行。</li></ul></li><li>开发板系统<ul><li>自9字班开始使用的新设备盒，注意开发板的启动模式选择EMMC启动</li></ul></li></ul></li><li>软件环境<ul><li>xshell版本: Xshell 7(Build 0122)</li><li>xftp版本: Xftp 7(Build 0119)</li><li>vmware版本: 16.2.2 build-19200509 </li><li>ubuntu版本: 18.04.6LTS (即课程提供的ubuntu)</li></ul></li></ul><h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><ul><li>利用Xshell串口工具连接开发板，并在Windows&#x2F;macOS系统上的VMware中的Ubuntu系统中编写相应程序，通过交叉编译生成目标文件，通过Xftp工具将编译好的程序传输至开发板运行。</li></ul><h3 id="实验操作步骤"><a href="#实验操作步骤" class="headerlink" title="实验操作步骤"></a>实验操作步骤</h3><div class="note red modern"><p>在实验操作流程当中遇到问题，可以先看下一节中的问题与解决，如果没有覆盖到读者的问题，那读者还需要去咨询有经验的同学。</p></div><ul><li>1、下载开发环境：从课程提供的下载链接(以每年最新链接为准)中下载开发环境(包含有虚拟机镜像、vmware安装程序、xshell安装程序、xftp安装程序)</li><li>2、导入虚拟机镜像：由于之前已经下载过 VMware Workstation，这里不再赘述。打开虚拟机，导入压缩包解压后得到的1804文件夹下的虚拟机镜像<code>Ubuntu 1804.vmx</code>，账号与密码均为<code>bkrc</code>。</li><li>3、安装下载的开发环境文件当中的xshell和xftp工具</li><li>4、xshell连接开发板: <ul><li>使用工具箱里的USB Type-B连接电脑与开发板</li><li>打开xshell，新建会话，在弹出的窗口中，协议选择<code>SERIAL</code>，名称随意，随后点击左侧列表中的<code>串口</code>，选择<code>端口号</code>，具体端口号需要到电脑的<code>设备管理器</code>中，找到<code>端口</code>一项,其中可以看到<code>Silicon Labs CP210x USB to UART Bridge(COMX)</code> 这里的X,在不同设备上是不同的，在我们小组的三位同学的电脑上分别为COM5,COM6,COM27.</li><li>点击<code>连接</code>即可</li><li>这样xshell就相当于开发板linux系统的终端，可以实现在开发板上的文件操作</li></ul></li><li>5、ftp连接<ul><li>使用工具箱里面的网线连接电脑与开发板</li><li>这里需要配置主机和开发板的ip<ul><li>电脑ip:<code>控制面板-&gt;网络和共享中心-&gt;更改适配器设置</code>,找到<code>以太网</code>接口，右键属性，在弹出的窗口中，双击<code>Internet 协议版本 4 (TCP/IPv4)</code>。选择<code>使用下面的IP地址</code>，然后输入IP地址<code>192.168.1.2</code>和子网掩码<code>255.255.255.0</code>。点击<code>确定</code>以保存设置。</li><li>开发板ip:这部分操作需要在xshell上进行，<code>ifconfig eth0 192.168.1.3 netmask 255.255.255.0</code>，可以用过<code>ifconfig</code>检查<code>ip</code>是否已经成功配置</li></ul></li><li>打开xftp工具，新建会话，名称随意，主机填写开发板的ip地址192.168.1.3，下面用户名写root，点击连接即可</li><li>这样xftp就实现了电脑与开发板系统的文件传输连接</li></ul></li><li>6、<strong>代码编写</strong>：在vmware workstation上的home目录下编写代码，参考助教提供的文件操作函数，函数的伪代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当处理 WAV 文件时，可以通过定义一个结构体来表示 WAV 文件头，这个结构体的成员变量对应着 WAV 文件头中的各个字段，从而可以方便地读取和解析 WAV 文件的信息。</span></span><br><span class="line"><span class="comment">// int 由uint32_t代替，short 由uint16_t代替，因为在跨平台后有可能不兼容</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WAV_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> chunk_id[<span class="number">4</span>]; <span class="comment">// riff 标志号</span></span><br><span class="line"><span class="type">uint32_t</span> chunk_size; <span class="comment">// riff长度</span></span><br><span class="line"><span class="type">char</span> format[<span class="number">4</span>]; <span class="comment">// 格式类型(wav)</span></span><br><span class="line">... <span class="comment">// 省略其余信息</span></span><br><span class="line"></span><br><span class="line">&#125; wav_header;</span><br><span class="line"><span class="type">int</span> wav_header_size; <span class="comment">// 接收wav_header数据结构体的大小</span></span><br><span class="line"></span><br><span class="line">FILE *fp; <span class="comment">// 音乐文件指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过使用 C 语言的标准库函数 fread，可以从音乐文件中读取文件头的数据，并将其存储到先前定义的 struct WAV_HEADER 结构体的实例 wav_header 中。</span></span><br><span class="line"><span class="comment">// 随后，通过访问 wav_header 结构体的成员变量，就可以获取 WAV 文件的各种信息，如 RIFF 标志、文件大小、文件格式等，从而进行后续的处理和输出。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_music_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path_name)</span>&#123;</span><br><span class="line">FILE *fptxt; <span class="comment">// 输出文件指针</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">100</span>] = <span class="string">&quot;[file name].txt&quot;</span> <span class="comment">// 新建的输出文本文档的名称</span></span><br><span class="line">     <span class="comment">// 通过fopen函数打开音乐文件</span></span><br><span class="line">fptxt = fopen(name, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">fp = fopen(path_name, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="comment">// 判断wav文件是否为空，为空则退出</span></span><br><span class="line"><span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;fclose(fp); fclose(fptxt); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="comment">// 把文件指针定位到文件的开头处</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="comment">// 读取文件，并解析文件头获取有用信息</span></span><br><span class="line">wav_header_size = fread(&amp;wav_header, <span class="number">1</span>, <span class="keyword">sizeof</span>(wav_header), fp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出读取到的wav文件的信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wav文件头结构体大小：%d \n&quot;</span>, wav_header_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RIFF标志：\t %c%c%c%c \n&quot;</span>, wav_header.chunk_id[<span class="number">0</span>], ...);</span><br><span class="line">... <span class="comment">// 省略输出wav文件剩余信息</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 同理，将输出信息写入 [file name].txt</span></span><br><span class="line"><span class="built_in">fprintf</span>(fptxt, <span class="string">&quot;RIFF标志：\t %c%c%c%c \n&quot;</span>, wav_header.chunk_id[<span class="number">0</span>], ...);</span><br><span class="line">... <span class="comment">// 省略写入wav文件剩余信息</span></span><br><span class="line">fclose(fptxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数用来解析命令行参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv [])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret; <span class="comment">// 用来获取参数类型</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 用来判断是否填入参数</span></span><br><span class="line"><span class="comment">// 遍历所有参数</span></span><br><span class="line"><span class="keyword">while</span>((ret = getopt(argc,argv,<span class="string">&quot;m:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">switch</span>(ret)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: <span class="comment">// 如果是m，则调用 open_music_file 函数</span></span><br><span class="line">open_music_file(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 说明错误使用了别的参数，print usage然后退出</span></span><br><span class="line">print usage</span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="number">0</span>)</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="comment">// 说明未使用参数，print usage然后退出</span></span><br><span class="line">        print usage</span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="number">1</span>)</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后关闭文件然后退出</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>7、代码编译: 在虚拟机中，先通过<code>gcc Music_App -o test.wav</code>本地编译测试test.wav文件，成功实现目标效果后，在home目录下，输入加载交叉编译环境指令<code>source /opt/st/myir/3.1-snapshot/environment-setup-cortexa7t2hf-neon-vfpv4-ostl-linux-gnueabi</code>,随后编译音乐播放器应用程序<code>$CC Music_App.c -o Music_App</code>生成<code>Music_App</code>(实际执行的指令以助教提供的为准，大作业材料不一定都是代代相传的)</li><li>8、目标文件的传输与执行：将文件通过xftp连接到开发板上，在xshell中输入ls可以查看到<code>Music_App</code>，通过<code>chmod 777 Music_App</code>指令赋予<code>Music_App</code>可执行文件权限，随后输入<code>./Music_App -m test.wav</code>运行程序，即完成了该实验。</li></ul><h3 id="实验中遇到的问题与解决方法"><a href="#实验中遇到的问题与解决方法" class="headerlink" title="实验中遇到的问题与解决方法"></a>实验中遇到的问题与解决方法</h3><ul><li>1、开发环境下载：在下载开发环境的时候，使用多开IDM同时下载六个压缩包文件，会导致下载文件错误，解压后的虚拟机镜像文件不可用。解决方法是删除下载文件，用IDM一个一个重新下载</li><li>2、xshell和xftp的安装：安装xshell和xftp的时候，警告需要更新版本，但是更新程序一直无响应，比较抽象。解决方法是去NetSarang Computer的<a href="https://www.netsarang.com/en/">官网</a>上，用学生邮箱申请免费版本，下载后安装即可</li><li>3、xshell串口端口: 在选择开发板串口端口号的时候，在电脑的<code>设备管理器</code>中，找到<code>端口</code>一项中无法找到<code>Silicon Labs CP210x USB to UART Bridge(COMX)</code> 。解决方法：上silabs的<a href="https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads">官网</a>,在软件下载处下载<code>CP210x Universal Windows Driver</code>,解压下载的压缩包，右键.inf文件安装即可，随后即可在电脑的<code>设备管理器</code>中，找到<code>端口</code>一项中的<code>Silicon Labs CP210x USB to UART Bridge(COMX)</code> 在串口端口号中选择对应的<code>COMX</code>即可</li><li>4、xshell确认与连接:在xshell创建会话中，配置好串口信息后，点击<code>确认</code>后，没有显示创建的会话。<ul><li>解决方式1：通过资料的查阅，了解到点击确认后，Xshell将保存用户所做的会话配置更改，但不会立即启动与目标设备的连接。关闭会话配置窗口后，用户可以在 Xshell 的会话管理器中找到刚才创建或修改的会话，双击会话条目或选择会话并点击 “连接” 按钮以建立连接。</li><li>解决方式2：在配置好串口信息后，点击<code>连接</code>而不是点击<code>确认</code>可以直接连接上会话</li></ul></li><li>5、xshell与开发板成功连接后，一直显示connected，而没有显示出终端输入的位置，也没有助教上课讲述的几分钟的加载过程。解决方式，助教指出这种现象是正常现象，只需要ctrl+C打断即可进入终端输入。</li><li>6、开发板ip的配置：这个地方比较的曲折，一开始通过查阅资料了解到可以将开发板挂在到虚拟机，经过一段尝试没有成功，后改用FTP客户端软件连接开发板文件系统，但是这个时候依旧没有使用网线，而是考虑给开发板和电脑连接手机热点，再进行ip配置，但是经过一段时间的尝试依旧失败，最后阅读ppt了解到需要使用网线连接开发板和电脑，再通过chatgpt查询到window和linux的ip配置，最终成功配置了两边的ip，连接上xftp</li><li>7、代码编写中的问题<ul><li>不了解wav文件的信息如何提取。通过查找<a href="https://www.cnblogs.com/ranson7zop/p/7657874.html">相关网站</a>，我们找到了拆解wav文件编码信息的方法，并通过将其定义为结构体的方式，将读入的wav文件的信息逐个对应到该结构体中的各个变量，从而可以正确地解析wav文件头。例如，<code>chunk_id</code>、 <code>chunk_size</code>、 <code>format</code> 等成员变量对应着 WAV 文件头中的 RIFF 标志、文件大小、文件格式等字段。</li><li>不熟悉c语言中字符串处理的方式</li><li>为了在后续开发中处理多个命令行参数，需要使用c语言中的<code>getopt</code>函数和<code>optarg</code>变量来循环解析命令行参数，并根据参数执行相应的操作。</li><li>需要用<code>uint32_t</code>代替<code>int</code>，用<code>int16_t</code>代替<code>short</code>，因为在交叉编译时不同数据类型有可能不兼容，导致类型长度不一致，因此选择使用统一的类型。</li></ul></li><li>8、执行程序在开发板上无法运行：这个部分是由于对ppt和项目参考文档的阅读的疏忽，可执行文件传输到开发板上没有赋予可执行文件权限，解决方法是:通过<code>chmod 777 Music_App</code>指令赋予<code>Music_App</code>可执行文件权限。</li><li>9、再次连接开发板重启实验时ip分配：当再次重启实验后，此时发现直接点击xftp中上一次会话不能顺利连接上开发板，经过检查主机的以太网ip分配记录是保留的，但是开发板上的ip需要重新配置，此时输入<code>ifconfig eth0 192.168.1.3 netmask 255.255.255.0</code>重新配置开发板ip即可</li><li>10、xftp中的无线网冲突：当xftp连接所需的ip都已经分配完毕，会话成功创建，但是显示无法连接到指定ip，这个时候可以检查主机上的无线网是否断开，无线网的连接会与以太网的连接相互冲突，这个时候需要断开无线网，xftp即可顺利连接。</li><li>11、打开xshell后再连接网线，此时xshell疑似进入网络传输模式，xftp通过网线无法连接开发板。解决方法：先连接网线，再打开xshell</li></ul><h2 id="实验优化"><a href="#实验优化" class="headerlink" title="实验优化"></a>实验优化</h2><p>本次进行的实验还有三个可优化的地方，作者自己没有实操过，感兴趣的同学可以自己探索:</p><ul><li>1、xftp实现虚拟机与开发板的直连，而不是通过windows或者macos作为虚拟机和xftp的中介，可以提高xftp的便携程度。</li><li>2、在U-Boot中使用<code>UMS 0 MMC 1</code>指令挂在开发板到虚拟机，可以实现在同一个虚拟机文件夹下同时操作虚拟机文件与开发板文件，可以减少实验流程，提高文件传输效率</li><li>3、在代码编写上:<ul><li>内存管理：目前的代码使用了结构体来保存文件头信息，如果WAV文件的文件头信息较大，可能会占用较多的内存。可以考虑使用动态内存分配，通过指针来操作文件头信息，从而减少内存占用。</li><li>性能优化：目前的代码是按字节读取文件头信息的，可以考虑使用更高效的方式，如按块读取，减少IO操作次数，提高性能。</li><li>命令行参数解析：目前的代码使用了简单的命令行参数解析方式，可以考虑使用更强大的命令行参数解析库，如<code>getopt_long</code>或<code>argp</code>，以支持更复杂的命令行参数选项和错误处理。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 作业指南 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>superset的安装与启动——虚拟环境与docker</title>
      <link href="/2023/04/21/superset-install-run/"/>
      <url>/2023/04/21/superset-install-run/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>superset的安装和启动流程参考于腾讯云开发者社区的一篇<a href="https://cloud.tencent.com/developer/article/1847601">博客</a>和superset的<a href="https://preset.io/blog/tutorial-contributing-code-to-apache-superset/">官网</a>和<a href="https://github.com/apache/superset/blob/master/CONTRIBUTING.md#setup-local-environment-for-development">帮助文档中的本地开发环境搭建部分</a>,解决问题部分的参考链接都附在文章当中。</p></div><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>最近在做iotdb和superset的一个连接工作，本以为安装superset不过上官网下载一下，走个安装流程即可，但是实际操作起来属于是一言难尽。真的是没想到一款知名的开源软件的安装和启动的报错竟然如此之多，读者可以在网上搜索superset，前几条信息除了superset的官网之外就是错误解决博客，甚至有博客专门列了个二十余项的报错清单讲解决之法。不过作者安装花费了这么长的时间，更多的还是因为前期对于这个安装工作的没有足够的重视，资料没有收集阅读全面就草草上手，以至于前后经历了安装生产环境版本、使用本地环境安装、使用虚拟环境安装、使用虚拟机安装和使用docker安装等曲折的历程，属实是比较痛苦。不过经历这些试错的环节，作者也是学习到了更丰富的知识，最后还是推荐使用虚拟环境或者docker实现superset的安装和启动。作者这里会分享一下包含生产环境与开发环境两个版本在内的superset的安装启动流程与错误解决。</p><h1 id="虚拟环境下的安装启动流程"><a href="#虚拟环境下的安装启动流程" class="headerlink" title="虚拟环境下的安装启动流程"></a>虚拟环境下的安装启动流程</h1><div class="note info modern"><p>先注明一下作者这里使用的python版本是3.8.9，电脑系统是windows,iotdb版本为1.1.1, node.js版本为16, npm的版本为8</p></div><h2 id="安装前言"><a href="#安装前言" class="headerlink" title="安装前言"></a>安装前言</h2><ul><li><p>对于生产环境和开发环境的两个版本的superset的安装流程大体上是一样的，但是在部分指令使用与错误处理上会有所不同。</p></li><li><p>读者需要注意，这里的流程不包含后续的数据库连接工作，如果需要连接数据库，自行在superset官网的<a href="https://superset.apache.org/docs/databases/installing-database-drivers">安装数据库驱动</a>中，找到自己想要使用的数据库驱动包(pypi packet)去pip，pip时机在初始化superset之前都可以，当然，数据库驱动包很可能会带来更多的报错，这部分的报错需要结合具体的数据库和报错去分析。</p></li><li><p>第一次安装的流程概述如下</p><ul><li>版本选择(开发环境)</li><li>虚拟环境的创建与启动</li><li>安装superset依赖</li><li>构建前端资源(开发环境)</li><li>初始化superset的元数据数据库</li><li>创建管理员用户&#x2F;初始化Superset的应用程序环境</li><li>启动superset</li></ul></li><li><p>对于已经启动过的读者来说，关掉虚拟环境后再次启动的流程概述如下</p><ul><li>虚拟环境的启动</li><li>初始化superset的元数据数据库</li><li>初始化Superset的应用程序环境</li><li>启动superset</li></ul></li></ul><h2 id="版本选择-开发环境"><a href="#版本选择-开发环境" class="headerlink" title="版本选择(开发环境)"></a>版本选择(开发环境)</h2><ul><li>首先对于开发环境下，源代码是必不可少的，直接从<a href="https://github.com/apache/superset">github</a>上拉取superset的源代码</li><li>因为作者是第一次参与开源社区的开发，不太清楚github里面哪些是稳定的分支可以pull，最开始是直接选用了master进行开发，后来遇到了一些bug，也是顺利解决。同时作者通过网络博客的学习，也参考了一些其他博主的版本去安装与启动，尝试了2.1,2.0,1.3,0.36等分支，这些分支出现的依赖问题、显示问题相较于master略多(这里讲述的是作者设备的情况，当然也可能是superset在最新的版本中解决了前面版本的部分问题)。</li><li>对于新入坑的读者，可以去superset的github主页找他们的联系方式，咨询一下最新的稳定版本</li></ul><p>下面介绍可能遇到的问题：</p><ul><li>报错1：克隆时候报错 Cloning into ‘superset’… error: RPC failed; curl 92 HTTP&#x2F;2 stream 3 was not closed cleanly before end of the underlying stream fatal: expected flush after ref listing<ul><li>这个说明在尝试克隆 Git 仓库时发生了问题。这可能是由于网络问题、服务器问题或 Git 配置问题引起的。</li><li>解决方法：再clone一次即可</li></ul></li></ul><h2 id="构建前端资源-开发环境"><a href="#构建前端资源-开发环境" class="headerlink" title="构建前端资源(开发环境)"></a>构建前端资源(开发环境)</h2><ul><li><p><strong>这里官网要求node.js需要达到版本16，npm需要达到版本7</strong></p></li><li><p>假设当前的开发目录是superset目录，那么需要依次执行下面四个指令<code>cd superset-frontend</code>，<code>npm ci</code>，<code>npm run build</code>,<code>cd ..</code></p></li><li><p>tips:</p><ul><li>视电脑性能的不同，构建过程需要等待几分钟到十几分钟不等</li><li>前端资源构建的这个操作位置是比较自由的，只需要在启动superset之前执行这个部分的指令即可，<strong>如果在superset之前没有执行前端资源构建，将会导致网页无法显示，表现为前端页面处于一种崩溃状态</strong></li><li>如果读者的开发工作涉及到superset前端的样式修改可以采用如下的两种方式进行开发<ul><li>每次修改之后都重新输入构建前端资源的指令</li><li>在前端资源构建和superset启动之后，执行<code>npm run dev-server</code>打开webpack的开发服务器，能够对前端资源进行热重载，可以实时反馈前端修改到网页上</li></ul></li></ul></li><li><p>报错1：出现大量<code>npm ERR!xxx</code>格式的报错信息行</p><ul><li>解决方法：这个报错可以在superset的github issue中找到: <a href="https://github.com/apache/superset/issues/23803">fail to npm install on superset-frontend at 2.1 version</a>,由于问题比较新，暂时还没有在2.1分支上解决这个问题的方法，作者是切换到master是可以顺利编译的，读者可以通过切换分支，选择一个不是2.1分支的版本继续下面的操作</li></ul></li><li><p>报错2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! code 1</span><br><span class="line">npm ERR! path D:\supersetconnect\superset\superset-frontend\node_modules\@applitools\eyes-storybook</span><br><span class="line">npm ERR! <span class="built_in">command</span> failed</span><br><span class="line">npm ERR! <span class="built_in">command</span> C:\Windows\system32\cmd.exe /d /s /c ..\AppData\Local\Temp\postinstall6852635.cmd</span><br></pre></td></tr></table></figure><ul><li>解决方法，这个报错表示在安装@applitools&#x2F;eyes-storybook包时发生了错误。根据错误日志，是在执行postinstall脚本时出现了问题。解决方法是删除superset-frontend目录下的node_modules文件夹，然后重新执行npm ci或者npm install命令，更新依赖即可解决。</li></ul></li><li><p>警告：这里会出现很多的warning，大多数说superset选用的版本较老，可以不予理会</p></li></ul><h2 id="虚拟环境的创建与启动"><a href="#虚拟环境的创建与启动" class="headerlink" title="虚拟环境的创建与启动"></a>虚拟环境的创建与启动</h2><p>这个部分我一开始是安装了python的virtualenv包来进行虚拟环境的创建，后来查阅资料了解到python3.3以上的版本自带了venv的虚拟环境，两者在这里拥有相似的效果，读者自行选择</p><ul><li><p>虚拟环境的创建</p><ul><li>对于virtualenv<ul><li>在终端使用<code>pip install virtualenv</code>指令安装virtualenv</li><li>找个合适的位置，在终端输入<code>virtualenv your_environment_name</code>创建虚拟环境</li></ul></li><li>对于venv<ul><li>在终端使用<code>python -m venv your_environment_name</code>创建虚拟环境</li></ul></li><li>上面表述中的<code>your_environment_name</code>替换为你想要的环境名称，例如<code>superset_venv</code>,指令产生的效果就是会在当前文件夹下创建一个名为<code>superset_venv</code>的文件夹，其中为虚拟环境的文件存放区域。后面就以<code>superset_venv</code>为例继续阐述流程</li></ul></li><li><p>虚拟环境的启动(再次强调，作者用的是windows系统，不是windows系统的指令会略有不同)</p><ul><li>在终端输入<code>superset_venv\Scripts\activate</code>激活虚拟环境，效果为看到命令提示符前面有一个表示虚拟环境名称的前缀，例如(superset_venv)。</li></ul></li></ul><h2 id="安装superset依赖"><a href="#安装superset依赖" class="headerlink" title="安装superset依赖"></a>安装superset依赖</h2><ul><li><p>推荐的先行操作:在终端当中输入<code>superset_venv\scripts\python.exe -m pip install --upgrade pip</code>将pip更新到最新版,注意这里的<code>superset_venv\scripts\python.exe</code>,这是在虚拟环境文件夹下有这么一个python.exe,如果执行报错,可以检查自己的终端路径或者将这里的相对路径<code>superset_venv\scripts\python.exe</code>改为绝对路径</p></li><li><p>这里的安装指令在开发环境和生产环境两个版本之间会略有不同</p><ul><li>对于生产环境，输入<code>pip install --upgrade apache-superset</code></li><li>对于开发环境，输入<code>pip install -r requirements/testing.txt</code><ul><li>这里之所以和生产环境不同，是因为生产环境使用的是稳定发布的apache-superset的python依赖包，和我们使用的apache-superset版本很可能不一致，直接安装apache-superset源码中的需求文件即可</li></ul></li></ul></li><li><p>等待依赖安装，如果这个过程没有报错，确实是值得恭喜的，可以进入第三步。下面是介绍作者在这里遇到的报错和解决方法</p></li><li><p>报错1：ERROR: Could not build wheels for python-geohash, which is required to install pyproject.toml-based projects</p><ul><li>解决方法：在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#python-geohash">Unofficial Windows Binaries for Python Extension Packages网站</a>上下载对应版本的预编译包。这里作者使用的python是3.8，且为x64的windows系统，所以需要下载的编译包为<code>python_geohash-0.8.5-cp38-cp38-win_amd64.whl</code>。将终端定位到下载文件位置，在终端先输入<code>pip install wheel</code>确认wheel包已经存在，再输入<code>pip install python_geohash‑0.8.5‑cp38‑cp38‑win_amd64.whl</code>即可，注意文件名换为读者所使用的的whl文件名。</li><li>网络上讲述的另一种方法——通过安装c++ build tool解决问题，我尝试了一半，发现需要用vs install安装几个G的东西，占内存、下载还很耗时，改用上面这种方式还是非常高效简洁</li></ul></li><li><p>报错2：与报错1相似，但是python-geohash换成mysqlclient</p><ul><li>解决方法：与报错1相似，在这个<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient">网址</a>上下载对应版本的预编译包。这里作者使用的python是3.8，且为x64的windows系统，所以需要下载的编译包为<code>mysqlclient‑1.4.6‑cp38‑cp38‑win_amd64.whl</code>。与报错1一样，在终端中检查wheel是否安装<code>pip install wheel</code>，再定位到whl文件所在文件夹去安装，指令为<code>pip install mysqlclient‑1.4.6‑cp38‑cp38‑win_amd64.whl</code></li></ul></li><li><p>报错3：与报错1相似，但是python-geohash换成sasl</p><ul><li>解决方法：与报错1相似，在这个<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#sasl">网址</a>上下载对应版本的预编译包。这里作者使用的python是3.8，且为x64的windows系统，所以需要下载的编译包为<code>sasl‑0.3.1‑cp38‑cp38‑win_amd64.whl</code>。与报错1一样，在终端中检查wheel是否安装<code>pip install wheel</code>，再定位到whl文件所在文件夹去安装，指令为<code>pip install sasl‑0.3.1‑cp38‑cp38‑win_amd64.whl</code></li></ul></li><li><p>报错4：ERROR: pip’s dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.apache-iotdb 1.1.0 requires sqlalchemy!&#x3D;1.3.21,&lt;1.4,&gt;&#x3D;1.3.16, but you have sqlalchemy 1.4.47 which is incompatible.apache-iotdb 1.1.0 requires sqlalchemy-utils&lt;0.38,&gt;&#x3D;0.37.8, but you have sqlalchemy-utils 0.38.3 which is incompatible.</p><ul><li>这个报错是因为作者使用的iotdb的python包对于sqlalchemy的版本限制与superset所使用的的sqlalchemy版本冲突。</li><li>解决方法: 简而言之就是去除这个iotdb的python包对于sqlalchemy的版本限制。电脑上需要有python3、pip3;使用<code>python3 -m pip install --user --upgrade setuptools wheel</code>和<code>python3 -m pip install --user --upgrade twine</code>指令安装setuptools和wheel和twine，进入到iotdb源码文件夹下的client-py文件夹，打开setup.py文件，修改版本号为任意非中文符号串，如<code>1.2.0-rc1</code>，随后去除<code>sglalchemy</code>和<code>&quot;sglalchemy-utils</code>的版本上限限制，随后执行<code>python3 setup.py sdist bdist_wheel</code>打包出一个临时的iotdb包(点击直接<a href="https://pan.baidu.com/s/1xDqRORvKamylGptjEy3Dfg?pwd=0000">下载</a>)——<code>client_py/dist/apache iotdb-1.2.0rc1-py3-none-any.whl</code>,随后在终端定位到这个文件的位置去安装这个whl文件，执行指令为<code>pip3 install apache iotdb-1.2.0rc1-py3-none-any.whl</code></li></ul></li></ul><h2 id="初始化superset的元数据数据库"><a href="#初始化superset的元数据数据库" class="headerlink" title="初始化superset的元数据数据库"></a>初始化superset的元数据数据库</h2><ul><li><p>在虚拟环境当中输入<code>superset db upgrade</code>，这里如果没有报错，可以进入下一步。下面介绍作者遇到的几个问题</p></li><li><p>报错1:Error: Could not locate a Flask application. You did not provide the “FLASK_APP” environment variable, and a “wsgi.py” or “app.py” module was not found in the current directory.</p><ul><li>需要设置flask_app这个环境变量为superset，但是作者尝试了<code>set FLASK_APP=superset</code>指令进行设置，但是使用<code>echo %FLASK_APP%</code>进行检查却发现一直没有设置成功。</li><li>解决方式:使用<code>$env:FLASK_APP = &quot;superset&quot;</code>设置flask_app,可以使用<code>echo $env:FLASK_APP</code>检查flask_app是否设置成功</li><li>需要注意，这里的解决方式中设置flask_app的方式是一种临时的设置方式，终端关掉重启就会取消，如果设备不是长期只使用superset还是不建议考虑设置成永久的，永久设置指令是用<code>setx</code>代替上面的<code>set</code>，这种设置是覆盖性质的，也就是要清除直接设置为空即可</li></ul></li><li><p>(生产环境) 报错2:AttributeError: module ‘sqlparse.keywords’ has no attribute ‘FLAGS’</p><ul><li>这是superset的一个离奇bug，多次出现在issue当中，我在issue当中找到了一个可行的<a href="https://github.com/apache/superset/issues/23742">解决方法</a>，这个方法的具体实现方式就是将<code>superset_venv\lib\superset\sql_parse.py</code>的<code>re.compile(r&quot;&#39;(&#39;&#39;|\\\\|\\|[^&#39;])*&#39;&quot;, sqlparse.keywords.FLAGS).match</code>改为<code>re.compile(r&quot;&#39;(&#39;&#39;|\\\\|\\|[^&#39;])*&#39;&quot;, re.IGNORECASE | re.UNICODE).match</code></li></ul></li><li><p>报错3:一个非常规整的warning，最后是Refusing to start due to insecure SECRET_KEY</p><ul><li>Superset 使用了默认的 SECRET_KEY，这可能会导致安全问题，于是拒绝执行</li><li>解决方法：<ul><li>对于生产环境<ul><li>在虚拟环境的终端当中输入<code>openssl rand -base64 42</code>获取一个密钥,随后在文件夹<code>superset_venv</code>的根目录,创建superset_config.py，把这个句子SECRET_KEY &#x3D; “密钥”写进superset_config.py即可</li></ul></li><li>对于开发环境<ul><li>在生产环境的基础上，在终端输入指令<code>set SUPERSET_CONFIG_PATH path\to\your\superset_config.py</code>或者<code>$env:SUPERSET_CONFIG_PATH = &quot;path\to\your\superset_config.py&quot;</code></li><li>这里的设置方式是一种临时的设置方式，终端关掉重启就会取消，如果设备不是长期只使用superset还是不建议考虑设置成永久的，永久设置指令是用<code>setx</code>代替上面的<code>set</code>，这种设置是覆盖性质的，也就是要清除直接设置为空即可</li></ul></li></ul></li><li>非常重要的一点是<code>openssl rand -base64 42</code>所获得的的密钥还请自己妥善保管，</li></ul></li><li><p>报错4:Can’t locate revision identified by ‘7e67aecbf3f1’</p><ul><li>因为作者一开始在本地环境上切换过版本，在其他版本中执行过<code>superset db upgrade</code>,造成本地留存了一个superset.db文件，而这个报错就是说这个留存的superset.db和当前使用的superset的版本不同</li><li>解决方法：找到superset.db，删除即可，重新运行<code>superset db upgrade</code>会再生成的</li><li>如果不知道这个superset.db在哪里，推荐电脑下载<code>everything</code>工具进行搜索</li></ul></li><li><p>除此之外，在开发环境当中，这里会有多个警告，这些警告可以忽略</p><ul><li><code>We haven&#39;t found any Content Security Policy (CSP) defined in the configurations...</code> 这是一个关于未定义内容安全策略 (CSP) 的警告。</li><li><code>Falling back to the built-in cache...</code>这是一个关于缓存配置的警告。</li><li><code>WARNI [alembic.env] SQLite Database support for metadata databases will be removed in a future version of Superset.</code>这是一个关于未来 Superset 版本将不再支持 SQLite 作为元数据数据库的警告。</li></ul></li><li><p>注意上述的操作都在虚拟环境的终端当中，错误解决之后需要运行一下<code>superset db upgrade</code></p></li></ul><h2 id="创建管理员用户-初始化Superset的应用程序环境"><a href="#创建管理员用户-初始化Superset的应用程序环境" class="headerlink" title="创建管理员用户&#x2F;初始化Superset的应用程序环境"></a>创建管理员用户&#x2F;初始化Superset的应用程序环境</h2><ul><li>在终端当中输入<code>superset fab create-admin</code>创建管理员用户，依次输入用户名、用户名字、用户姓氏、邮箱、密码、确认密码</li><li>需要注意，用户名和密码是用于后续登录superset网站的</li><li>在终端输入<code>superset init</code>的应用程序环境，如果前面没有创建管理员用户，且superset当中不存在用户记录，那么这句指令将会强制要求创建一个。</li></ul><h2 id="启动superset网站"><a href="#启动superset网站" class="headerlink" title="启动superset网站"></a>启动superset网站</h2><ul><li>在终端输入<code>superset run -p 8080 --with-threads --reload --debugger</code>,这里的<code>superset</code>很多博客甚至官网教程都是用<code>flask</code>，两者效果是一样的。随后可以在终端的输出当中找到一个本地网站链接<code>http://127.0.0.1:8080/</code>,或者直接在浏览器当中输入这个网址启动即可</li><li>到这里superset的启动也是顺利结束了</li></ul><h1 id="docker下的安装启动流程"><a href="#docker下的安装启动流程" class="headerlink" title="docker下的安装启动流程"></a>docker下的安装启动流程</h1><p>用docker实现superset的安装和启动应该是最为稳定的方式，一方面是因为可以与本地环境完全隔离，不用担心本地环境对于superset安装的影响，另一方面是使用的linux的镜像，在指令使用上与官方推荐也更为贴合。不过由于作者在最后改用docker去完成安装和启动的过程中，前面虚拟环境的部分的bug得到了解决，已经可以顺利启动。这个部分的文案就暂且搁置，等之后完成这个项目之后再来补充。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> superset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> superset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android studio 和 spring boot 基于 Okhttp 的前后端连接实现</title>
      <link href="/2023/04/17/android_springboot_okhttp/"/>
      <url>/2023/04/17/android_springboot_okhttp/</url>
      
        <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>作者最近在写安卓大作业，需要实现<code>android studio</code>和后端连接，尝试了一下<code>django</code>的后端，一直连不上，等之后作者探索出来再来写一篇博客，后来换成<code>spring boot</code>的后端，资料确实是更多，在连接过程也遇到了一些小问题，查阅了些资料得到解决，于是做个记录，方便遇到相同问题的读者能够顺利解决。</p><h1 id="前后端连接实例"><a href="#前后端连接实例" class="headerlink" title="前后端连接实例"></a>前后端连接实例</h1><p>这里直接列举一个简单的前后端连接实例，方便大家学习参考</p><h2 id="实例概述"><a href="#实例概述" class="headerlink" title="实例概述"></a>实例概述</h2><p>本次实例使用<code>android studio</code>完成app的前端，使用<code>spring boot</code>完成app的后端，前端当中写一个按钮，点击后把”hello”传递给后端，后端接收到”hello”后把”hi”传递回前端，并显示在按钮上，其中使用<code>OkHttp</code>的前后端通信方式。</p><h2 id="实例的实现流程"><a href="#实例的实现流程" class="headerlink" title="实例的实现流程"></a>实例的实现流程</h2><h3 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a>1、环境配置</h3><ul><li>前端作者是用<code>android studio</code>来制作的，所以直接上官网下载就行；</li><li>后端<code>spring boot</code>是基于<code>intellj idea</code>的，可以上官网下载<code>intellj idea</code></li><li>语言这里使用的是<code>java8</code></li></ul><h3 id="2、spring-boot后端项目创建"><a href="#2、spring-boot后端项目创建" class="headerlink" title="2、spring boot后端项目创建"></a>2、spring boot后端项目创建</h3><div class="note info modern"><p>需要注意，<code>intellj idea</code>专业版和社区版在这里应该是会有所不同，作者使用的是专业版(学生认证的，可能需要几天)</p></div><p><code>intellj idea</code>左上角点击<code>文件-&gt;新建-&gt;项目</code>，左侧选择<code>Spring Initializr</code>，自己设定<code>项目名称</code>、选择<code>项目位置</code>，<code>创建git仓库</code>按需点击，<code>语言</code>这里选择<code>java</code>(Kotlin和Groovy作者都不认识hhh)，<code>类型</code>(包管理)选择<code>Maven</code>，<code>组名、工件、软件包</code>名称会按照项目名称自动修改，<code>JDK</code>和<code>java语言</code>的版本需要适配，作者这里选的是jdk1.8和java8如果选错了可以创建后在<code>文件-&gt;项目结构</code>当中修改，<code>打包</code>这里选择<code>jar</code>(如果有部署到专门的应用服务器的需求，可以选择WAR，这个后期也是可以修改的，这里不赘述)。完成后点击<code>下一步</code>。</p><p>上面的<code>spring boot</code>选择2版本里面不带SNAPSHOT的最新版，作者这里是2.7.10。随后在依赖项当中搜索<code>Spring Web</code>或者点击Web展开即可看见<code>Sping Web</code>，点击勾选。点击右下角<code>创建</code>即可。</p><h3 id="3、spring-boot后端项目编写"><a href="#3、spring-boot后端项目编写" class="headerlink" title="3、spring boot后端项目编写"></a>3、spring boot后端项目编写</h3><p>这里使用<code>spring boot</code>的好处就是啥都不需要额外配置，直接实现功能代码就完事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 项目根目录下 src-&gt;main-&gt;java-&gt;com.example.xx 右键 新建-&gt; java类，命名为MessageController,代码如下</span></span><br><span class="line"><span class="comment">// 注意文件原有代码的第一行的包别给删了 一般格式为 package com.example.xx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// 这个是一个注解，使其可以被主类自动识别和注册，不需要在主类当中调用就可以直接被使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/message&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">receiveMessage</span><span class="params">(<span class="meta">@RequestParam</span> String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;hello&quot;</span>.equalsIgnoreCase(message)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;unknown message&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、spring-boot后端项目运行"><a href="#4、spring-boot后端项目运行" class="headerlink" title="4、spring boot后端项目运行"></a>4、spring boot后端项目运行</h3><p>打开后端项目根目录下<code>src/main/java/com.example.xx</code>，在这里，有一个土著java文件，其名称和项目名称有关系，我这里是<code>backendapplication</code>，打开后点击工具栏的<code>运行</code>符号就是一个三角形。</p><h3 id="5、android-studio前端项目创建"><a href="#5、android-studio前端项目创建" class="headerlink" title="5、android studio前端项目创建"></a>5、android studio前端项目创建</h3><p>打开<code>android studio</code>后，<code>new project</code>，选择一个<code>empty activity</code>,自己设定<code>项目名称</code>、选择<code>项目位置</code>，语言为<code>java</code>，<code>minimum SDK</code>选择默认是<code>Android 7.0</code>,点击finish即可创建项目</p><h3 id="6、android-studio前端代码编写"><a href="#6、android-studio前端代码编写" class="headerlink" title="6、android studio前端代码编写"></a>6、android studio前端代码编写</h3><p>这里主要涉及okhttp的引入，前后端环境的相关配置，okhttp的调用，目标url设置等关键问题</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先在app项目下的build.gradle引入okhttp依赖</span></span><br><span class="line">dependencies<span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    implementation &#x27;com.squareup.okhttp3<span class="punctuation">:</span>okhttp<span class="punctuation">:</span><span class="number">4.9</span><span class="number">.3</span>&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 其次是在AndroidManifest.xml当中实现前后端环境相关的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 这里是设置internet权限 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:usesCleartextTraffic</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="comment">&lt;!-- 这里是设置允许明文传输 --&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是实现app/src/main/res/layout/activity_main.xml当中的按钮 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_send&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Send&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是在app/src/main/java/com.example.xx/MainActivity实现okhttp的调用以及目标url设置</span></span><br><span class="line"><span class="comment">// 注意文件原有代码的第一行的包别给删了 一般格式为 package com.example.xx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> okhttp3.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button buttonSend;</span><br><span class="line">    <span class="keyword">private</span> OkHttpClient client;</span><br><span class="line">    <span class="comment">// 这里的url设置是比较有讲究的，在Android模拟器上运行应用，需要使用特殊的IP地址 10.0.2.2，因为模拟器使用了虚拟网络，这个特殊IP地址会将请求转发到宿主机（运行模拟器的电脑）。当然这里的url可以设置为电脑当前的ip地址，不过存在一个小缺陷就是别人打开这个项目时候，如果ip发生了变化，那么就无法运行</span></span><br><span class="line">    <span class="comment">// 如果是在实际的手机上测试这个应用，需要这里的url需要设置为spring boot所在设备的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;http://10.0.2.2:8080/message&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        client = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>(); <span class="comment">// 创建okhttp客户端</span></span><br><span class="line">        buttonSend = findViewById(R.id.button_send);</span><br><span class="line"></span><br><span class="line">        buttonSend.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123; <span class="comment">// 点击函数</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                sendMessage(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">RequestBody</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder() </span><br><span class="line">                .add(<span class="string">&quot;message&quot;</span>, message)</span><br><span class="line">                .build(); <span class="comment">// 创建信号体，装入需要传输的信息</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(URL)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build(); <span class="comment">// 创建信号传输的对象，这里指定了目标url和携带的内容</span></span><br><span class="line"></span><br><span class="line">        client.newCall(request).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123; <span class="comment">// 使用okhttp客户端发送消息</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123; <span class="comment">// 消息传输失败</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123; <span class="comment">// 获取返回信息</span></span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">responseText</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">                    runOnUiThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            buttonSend.setText(responseText);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、android-studio前端项目运行"><a href="#7、android-studio前端项目运行" class="headerlink" title="7、android studio前端项目运行"></a>7、android studio前端项目运行</h3><p>在android studio右上角选择虚拟设备(如果没有可以直接创建，读者可以自行搜索，这里不再赘述)，设备的选择并不重要，有就行，随后点击<code>运行</code>的三角形符号</p><h3 id="8、实例效果描述"><a href="#8、实例效果描述" class="headerlink" title="8、实例效果描述"></a>8、实例效果描述</h3><p>运行出来之后会有一个send的按钮，点击之后会给后端传一个hello，后端如果识别到hello会给前端传hi，然后会把hi显示在按钮上，按钮上的文字从send变为hi</p><h1 id="相关问题与解决"><a href="#相关问题与解决" class="headerlink" title="相关问题与解决"></a>相关问题与解决</h1><ul><li>intellj idea新建spring boot项目后编译报错，报错信息如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">报错1：无法访问org.springframework.boot.springapplication错误的类文件:/c:/users/lxt13/.m2/repository/org/springframework/boot/spring-boot/3.0.5/spring-boot-3.0.5.jar!/org/springframework/boot/springapplication.class 类文件具有错误的版本 61.0, 应为 52.0 请删除该文件或确保该文件位于正确的类路径子目录中。</span><br><span class="line">报错2：java: 警告: 源发行版 17 需要目标发行版 17</span><br></pre></td></tr></table></figure><ul><li>原因解释：这是因为使用了2023年的最新版的spring boot3不兼容的java版本造成，spring boot3全面支持java17，版本小于17的java不能够支持其运行</li><li>解决方式: 在前面的<code>实例的实现流程</code>的<code>2、spring boot后端项目创建</code>当中提到，选用spring boot2的最新版即可解决。或者读者考虑配置java17的相关环境，从而体验比较新的spring boot3</li></ul></li><li>android studio对于拒绝连接http这种不安全协议，报错信息为<code>java.net.UnknownServiceException: CLEARTEXT communication not supported</code><ul><li>原因解释: android studio当中的一个默认设置的，在android 7.0以后，为了手机操作系统的安全，android studio默认拒绝使用http这种通过明文传输的不安全协议</li><li>解决方式: 在前面的<code>实例的实现流程</code>的<code>6、android studio前端代码编写</code>当中提到，在<code>AndroidManifest.xml</code>当中，给<code>application</code>的属性增加一条<code>android:usesCleartextTraffic=&quot;true&quot;</code>即可</li></ul></li><li>android studio缺少internet权限,报错信息为<code>java.net.SocketException: socket failed: EPERM (Operation not permitted)</code><ul><li>原因解释: 使用okhttp实现前后端连接需要赋予android studio网络权限</li><li>解决方式: 在前面的<code>实例的实现流程</code>的<code>6、android studio前端代码编写</code>当中提到，在<code>AndroidManifest.xml</code>当中，在<code>manifest</code>标签下，与<code>application</code>同级位置添加上<code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; </code>即可</li></ul></li><li>android studio中baseurl的选择:<ul><li>需要注意，这里的android studio的程序是在andorid虚拟设备上运行，与spring boot并不在同一个设备上，这里的url不能使用<code>127.0.0.1</code>或者<code>localhost</code>，这里的url设置是比较有讲究的，在Android模拟器上运行应用，需要使用特殊的IP地址 10.0.2.2，因为模拟器使用了虚拟网络，这个特殊IP地址会将请求转发到宿主机（运行模拟器的电脑）。当然这里的url可以设置为电脑当前的ip地址，不过存在一个小缺陷就是别人打开这个项目时候，如果ip发生了变化，那么就无法运行。如果是在实际的手机上测试这个应用，需要这里的url需要设置为spring boot所在设备的ip</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 前后端连接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决gitpush指令不稳定提交问题</title>
      <link href="/2023/03/25/solution-github-push/"/>
      <url>/2023/03/25/solution-github-push/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本篇文章主要基于<a href="https://xrebirth.github.io/">小靳同学</a> 的 <a href="https://xrebirth.github.io/posts/6204da2e.html#!">解决gitpush&#x2F;pull&#x2F;clone操作时的443错误&#x2F;GitHub无法访问问题</a>, 作者记录一下自己的理解</p></div><h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>作者萌新在刚学会git后就开始用git对大作业进行版本控制，但是在git push的时候，总是会遇到很糟心的timeout，具体报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to connect to github.com port 443 after 21074 ms: Timed out</span><br></pre></td></tr></table></figure><p>一开始感觉很玄学，虽然知道github是处于一种科学与非科学的量子叠加态的，但是不论是科学还是非科学上网都会有这样的报错，可能需要反复push好几次才有可能有一次成功。于是作者查阅了一些相关的资料，有了一点解决的方法，希望能够帮助到与作者有相似情况的读者。相比于小靳同学的文章，我这里只介绍我自己实践验证后成功的方式。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>1、在自己的科学上网的软件上可以很容易查找到自己的端口号，例如 <code>V2某</code> 的界面中就非常直观可以看到端口一列，在<code>cla某</code>的general第一行就是端口号。其他方式的科学上网端口号位置可以自己搜索</p><p>2、(可选) 就是在给git设置代理之前，先检查是否已经有代理了，在git中输入以下指令检查代理设置情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br></pre></td></tr></table></figure><p>如果没有返回内容，就说明没有设置过，可以直接进行第三步，如果有返回显示，说明曾经设置过相关代理(曾经设置过还会有这种情况，说明当前的端口号和曾经设置的端口号不一样了)，可以使用以下指令删除代理设置，再进行第三步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>3、设置git代理，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &#x27;http://127.0.0.1:7890&#x27; // 7890替换成自己的端口号</span><br><span class="line">git config --global https.proxy &#x27;http://127.0.0.1:7890&#x27; // 7890替换成自己的端口号</span><br></pre></td></tr></table></figure><p>这两个指令分别将git的http和https协议的代理为本地的http代理。通过这个设置，我们执行<code>git push</code>操作的时候，git会根据这个代理来建立网络连接。如果没有这个设置，git会直接连接到远程仓库进行push操作，这种情况下只有网络环境可以直接访问外网才能稳定的实现push操作。</p><p>4、(可选)使用2中的检查代理设置指令可以检查3中的代理是否设置成功</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在 <a href="https://xrebirth.github.io/posts/6204da2e.html#!">解决gitpush&#x2F;pull&#x2F;clone操作时的443错误&#x2F;GitHub无法访问问题</a> 一文中的情况3下面，还有一个设置socket代理的指令，由于我对socket代理不是很熟悉，所以本文没有提到相关设置。但是有一点值得一提，socket代理和http代理本身是互斥的，一个简单的例子：如果先给git设置了本地socket代理，再设置本地http代理，后设置的本地http代理将会覆盖前面的本地socket代理，最后效果就等价于只设置了本地http代理。因此对于使用socket代理还是http代理的问题，读者可以选择自己比较熟悉的一种方式去设置。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的常用指令笔记</title>
      <link href="/2023/03/25/hexo_order/"/>
      <url>/2023/03/25/hexo_order/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>先记录一下常用指令，后面来补一下怎么从零搭建一个hexo博客，再记录一下hexo的<a href="https://hexo.io/docs/">官网</a></p></div><p>hexo博客的常用指令及其作用如下表</p><table>    <tr>        <th width="300px">指令</th>        <th>作用</th>    </tr>    <tr>        <td> hexo new layout title </td>        <td> 只用指定的布局和标题创建新文章，布局分为draft,page,post三种</td>    </tr>    <tr>        <td> hexo publish filename </td>        <td> 将指定文件名的draft转移到post中，并更新日期。也可以手动移动</td>    </tr>    <tr>        <td> hexo generate 或 hexo g </td>        <td> 本地生成网站静态文件 </td>    </tr>    <tr>        <td> hexo server 或 hexo s </td>        <td> 启动本地服务器预览网站 </td>    </tr>    <tr>        <td> hexo deploy 或 hexo d </td>        <td> 将本地文件部署到远程服务器 </td>    </tr>    <tr>        <td> hexo clean </td>        <td> 清除生成的静态文件以及缓存 </td>    </tr>    <tr>        <td> hexo list type </td>        <td> 用于列出所有type的资源，type可以取page,post,route,tag,category </td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile基础内容学习笔记</title>
      <link href="/2022/09/23/makefile_note/"/>
      <url>/2022/09/23/makefile_note/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>这篇文章是阅读廖雪峰老师的<a href="http://www.ruanyifeng.com/blog/2015/02/make.html">文章</a> 后的一点笔记和心得</p></div><h1 id="makefile文件学习"><a href="#makefile文件学习" class="headerlink" title="makefile文件学习"></a>makefile文件学习</h1><h2 id="规则格式"><a href="#规则格式" class="headerlink" title="规则格式"></a>规则格式</h2><p>规则格式如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><p>格式解释：</p><ul><li>目标target : 目标是规则名，常常设置为文件名或者操作目的，同时一条规则可以有多个目标，可以理解为，多个目标有相同的command，然后就可以合并写。需要注意的是，makefile文件的目标会优先构建文件，因此操作目的需要与文件名有所区分，如果存在与操作目的同名的文件，那么该规则会认为没有必要重新构建该文件，因此不会触发。如果想要避免这种情况，可以在文件中加上<code>.PHONY: &lt;target&gt;</code> (位置随意，有就行，写在最前面或者最后面的比较多见) 值得注意的是如果make命令没有指定目标，那么将会默认为makefile文件的第一个目标</li><li>前置条件prerequisites<label id="rebuild">: 通常为一组文件名、也可以理解为一组目标，用空格隔开。如果前置条件中有文件不存在，那么将会调用该文件名对应的规则去生成。如果前置条件中所有文件都存在，且其生成时间比目标文件的生成时间早，那么就不需要重新构建；如果存在生成时间比目标文件的生成时间晚的前置文件，或者目标文件不存在，就会重新生成目标文件。</li><li>命令command：一条或者多条shell命令，通常需要能够构建目标文件。如果有多行shell指令的话将会在相互独立的shell中执行，同一行的多条指令将会按照次序在同一个shell中执行；如果想要多行shell也在同一个shell中执行，可以在目标上一行加上<code>.ONESHELL</code>,也可以在每一行后面加上<code>\</code>表示把换行符转义</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>#</code>在makefile中表示注释</p><h3 id="回声"><a href="#回声" class="headerlink" title="回声"></a>回声</h3><p>make执行的规则前会将该规则的command(包括注释)打印在终端上，如果不需要哪一行内容打印可以在对应的command前面加上@，通常会在注释前面加上</p><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o:%.c</span></span><br></pre></td></tr></table></figure><p>这一条指令会将当前目录下的所有的 .c文件 执行command变为对应的 .o 文件<br>具体命令行怎么写，可以参考后文提到的自动变量之一的$* </p><h3 id="变量和赋值符"><a href="#变量和赋值符" class="headerlink" title="变量和赋值符"></a>变量和赋值符</h3><h4 id="普通变量定义："><a href="#普通变量定义：" class="headerlink" title="普通变量定义："></a>普通变量定义：</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义时扩展（静态扩展），还是在运行时扩展（动态扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量  在执行时扩展，允许递归扩展。作者不是很理解递归扩展的作用，感觉不是很需要使用到，这部分可以理解为普通变量定义</span></span><br><span class="line">txt = hello world <span class="comment"># 定义了一个变量 并赋值为 hello world</span></span><br><span class="line"><span class="comment"># 调用变量</span></span><br><span class="line"><span class="variable">$(txt)</span> <span class="comment"># 使用$() 中加入变量的方式，可以实现替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在定义时扩展。常见于定义路径</span></span><br><span class="line">VARIABLE := value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br><span class="line">VARIABLE += value</span><br></pre></td></tr></table></figure><h4 id="内置变量定义"><a href="#内置变量定义" class="headerlink" title="内置变量定义"></a>内置变量定义</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内置变量</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="comment">#指向当前使用的编译器</span></span><br><span class="line"><span class="variable">$(MAKE)</span> <span class="comment">#指向当前使用的Make工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 例子</span></span><br><span class="line"><span class="section">output:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o output input.c</span><br></pre></td></tr></table></figure><h4 id="自动变量定义"><a href="#自动变量定义" class="headerlink" title="自动变量定义"></a>自动变量定义</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动变量</span></span><br><span class="line"><span class="variable">$@</span> <span class="comment"># 指代当前目标，就是Make命令当前构建的那个目标。</span></span><br><span class="line"><span class="variable">$*</span> <span class="comment"># 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。可以参考前文模式匹配中的操作</span></span><br><span class="line"><span class="variable">$&lt;</span> <span class="comment"># 指代第一个前置条件。</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$?</span> <span class="comment"># 指代比目标更新的所有前置条件</span></span><br><span class="line"><span class="variable">$^</span> <span class="comment"># 指代所有前置条件</span></span><br><span class="line"></span><br><span class="line">$(@D)、$(@F) <span class="comment"># 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。</span></span><br><span class="line">$(&lt;D)、$(&lt;F) <span class="comment"># 分别指向 $&lt; 的目录名和文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">a.txt b.txt: </span><br><span class="line">    touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">dest/%.txt: src/%.txt # 将src目录下的txt文件都拷贝到dest目录下</span></span><br><span class="line">    @[ -e dest ] || mkdir dest <span class="comment"># 判断dest目录是否存在，不存在则创建一个,这部分可以学习shell语言了解</span></span><br><span class="line">    cp <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="判断与循环"><a href="#判断与循环" class="headerlink" title="判断与循环"></a>判断与循环</h3><p>判断语法实例如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">  libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>循环操作实例如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组类型变量定义 循环的写法 shell中的循环写法</span></span><br><span class="line">LIST = one two three</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in <span class="variable">$(LIST)</span>; do \</span><br><span class="line">        echo $$i; \</span><br><span class="line">    done</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in one two three; do \</span><br><span class="line">        echo $$i; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>使用函数的格式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(function arguments)</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$&#123;function arguments&#125;</span><br></pre></td></tr></table></figure><p>常用的函数如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subst 函数 替换文本 语法格式如下</span></span><br><span class="line"><span class="variable">$(<span class="built_in">subst</span> from,to,text)</span> <span class="comment"># 其中from to text 可以是变量也可以是实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span> <span class="comment"># 将字符串&quot;feet on the street &quot;替换成&quot;fEEt on the strEEt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># patsubst 函数 用于模式匹配的替换 语法格式如下“</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br><span class="line"><span class="section">$(text: pattern = replacement) # 简写模式，用于替换后缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子如下：</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span> <span class="comment"># 将文件名&quot;x.c.c bar.c&quot;，替换成&quot;x.c.o bar.o&quot;。</span></span><br><span class="line"><span class="section">$(OUTPUT:.js=.min.js) # 将OUTPUT中的后缀名.js 替换为 .min.js</span></span><br></pre></td></tr></table></figure><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>我理解的makefile就是一个shell指令的一个批处理操作，对于每一个目标target，就是这一条规则将会生成的文件或者达到的效果。而前置条件，也是一些target，为了区别于目标名，这里将前置条件的target可以记作protarget，就是要实现target就得先实现protarget，就是基于这个思路，可以设置一个指令的批处理操作，而其对于重构target的标准中对于<a href="#rebuild">时间戳的考量</a>，则是其能够提高编译效率的一个关键。至于其中提到的command，对于初学者，这一部分是最让人懵逼的，但是仔细一看，需要记忆的也只有一些专有的变量和函数，而且实际的命令写法则是shell脚本语言，所以学习makefile之前最好能先修shell脚本语言,这里可以看看菜鸟教程关于shell脚本语言的<a href="https://www.runoob.com/linux/linux-shell.html">介绍</a>，之后作者也会更新相关的知识笔记。</p><p>其实对于makefile的使用频率是很少的，因为一个项目往往只需要一个makefile，甚至多个类似的项目使用的makefile几乎一模一样，可以直接copy，而且其在项目初期建立之后往往很少需要改动(如果项目里面的makefile需要常常改动，那这个项目大概率是不适合使用makefile的)。因此makefile实际练手的机会是比较少的，我觉得可以通过先修shell之后，再来结合makefile能够编写出一些shell小脚本，这样makefile和shell都能得到锻炼。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
